/* **********************************************************************
ANALISADOR LÉXICO
************************************************************************

Integrantes: 
Caio Gomes                  7239072
Diego Gomes                 7656467
Fernando Cury Gorodscy      7152354
Roberty Manzini Bertolo     7573399
Vanessa Apolinário Lima     7239256

Documento:
Codigo fonte

Nome:
MeuPhoria

************************************************************************/


/*****************************************
Opções
*****************************************/
options {
    STATIC = false;
    DEBUG_LOOKAHEAD = false;
    COMMON_TOKEN_ACTION = true ;
}

/*****************************************
Inicialização do Analisador Léxico
*****************************************/
PARSER_BEGIN(Meuphoria)

/* MeuPhoria Parser */
class Meuphoria {

    private static int errors = 0;
    private static boolean checkDeclaration = false;
    private static int _return = 0;
    private static Token call = null;
    private static java.util.ArrayList<Type> _return_param = null; //new java.util.ArrayList<Type>();

// Processa o código e gera a tabela de tokens
    public void processa() throws ParseException, TokenMgrError {
        Token t;
        String nomeToken;
        do {
// Pega o próximo token gerado pelo Léxico.
            t = getNextToken();
            if(t.kind == IDENTIFIER) {
// Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
                if(t.image.length() > 30)
                    throw new TokenMgrError();
            }
// Pega o proximo token do tipo t.kind
            nomeToken = tokenImage[t.kind];
// Seta a localização do token
            String location = "@(" + t.beginLine + ", " + t.beginColumn + ")";
// Imprime as informações do token. Se for EOF não imprime image, pois ela não existe.
            if(t.kind == EOL)
                System.out.println(String.format("%-15s %-20s <EOL>", location, nomeToken));
            else
                System.out.println(String.format("%-15s %-20s %s", location, nomeToken, t.image));
        } while (!(nomeToken.equals("<EOF>"))); // Termina o loop se EOF
        System.out.println(String.format("%s", t.image));
    }

/** Main entry point. */
public static void main(String args[]) {
    try
    {
        java.io.InputStream tmp = System.in;

        java.io.InputStreamReader is = new java.io.InputStreamReader(tmp);
        java.lang.StringBuilder sb=new java.lang.StringBuilder();
        java.io.BufferedReader br = new java.io.BufferedReader(is);
        try {
            String read = br.readLine();

            while(read != null) {
                sb.append(read + "\n");
                read =br.readLine();

            }
        }
        catch(java.io.IOException e) {
            System.out.println(e.getMessage());
        }

        // Define o analisador sintatico de acordo com a entrada do sistema
        Meuphoria analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

        analisadorSintatico.variables_declaration();

        checkDeclaration = true;
        _return = 0;
        _return_param = null;
        analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

        analisadorSintatico.javacc_input();
    }
    catch(ParseException e)
    {
        System.out.println(e.getMessage());
        System.out.println("Ocorreu uma excecao!");
    }
    catch(TokenMgrError e)
    {
        System.out.println(e.getMessage());
        System.out.println("Existem erros no codigo! Por favor, verifica-los.");
    }
}
}
PARSER_END(Meuphoria)



TOKEN_MGR_DECLS : { 

//Ação executada para cada Token encontrado
    void CommonTokenAction(Token t) {
        if(t.kind == IDENTIFIER) {
// Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
            if(t.image.length() > 30)
                throw new TokenMgrError();
        }
    }
}



/*****************************************
SKIP
*****************************************/
SKIP : { " " | "\t" | "\r" }

/* Skip Comentários de linha e de bloco */
SKIP :
{
    "/*" : WithinComment
    | <COMENTARIO_INICIAL : "#" (~["\n","\r"])*  >
    | <COMENTARIO_LINHA: "--" (~["\n","\r"])* >
}

<WithinComment> SKIP :
{
    "*/" : DEFAULT
}

<WithinComment> MORE :
{
    <~[]>
}

/*****************************************
TERMINAIS
*****************************************/
TOKEN : {
    < EOL : "\n" >
}

/*****************************************
PALAVRAS RERSERVADAS
*****************************************/
TOKEN : {
    <CASE : "case">
    | <DO : "do">
    | <END : "end">
    | <EXPORT : "export">
    | <GLOBAL : "global">
    | <INCLUDE : "include">
    | <PUBLIC : "public">
    | <SWITCH : "switch">
    | <UNTIL : "until">
    //| <CONSTANT : "constant">
    | <ELSE : "else">
    | <ENTRY : "entry">
    | <FALLTHRU : "fallthru">
    | <GOTO : "goto">
    | <LABEL : "label">
    | <RETRY : "retry">
    | <THEN : "then">
    | <WHILE : "while">
    | <BREAK : "break">
    | <CONTINUE : "continue">
    | <ELSEDEF : "elsedef">
    | <ENUM : "enum">
    | <IF : "if">
    | <LOOP : "loop">
    | <OVERRIDE : "override">
    | <RETURN : "return">
    | <TO : "to">
    | <WITH : "with">
    | <BY : "by">
    | <ELSIF : "elsif">
    | <EXIT : "exit">
    | <FUNCTION : "function">
    | <IFDEF : "ifdef">
    | <PROCEDURE : "procedure">
    | <TYPE : "type">
    | <WITHOUT : "without">
    | <SAVE : "save">
    | <STRICT : "strict">
    | <ELSEIFDEF : "elsifdef">
    | <FOR : "for">
    | <PRINT : "?">
}

/*****************************************
SEPARADORES
*****************************************/
TOKEN : { 
    <LPAREN: "(" >
        | <RPAREN: ")" >
| <LBRACE: "{" >
| <RBRACE: "}" >
| <LBRACKET: "[" >
| <RBRACKET: "]" >
| <SEMICOLON: ";" >
| <COMMA: "," >
| <DOT: "." >
| <#SINGLE_QUOTE: "\'" >
| <SLICE: ".." >
| <#QUOTE: "\"">
| <#TRIPLE_QUOTE: "\"\"\"">
| <COLON : ":">
}

/*****************************************
OPERADORES
*****************************************/
TOKEN : {
    <NOT_OP: "not" >
    | <PLUS: "+" >
    | <MINUS: "-" >
    | <STAR: "*" >
    | <SLASH: "/" >
    | <ESCLEAD: "\\">
    | <CONCAT: "&" >
    | <GT: ">" >
    | <LT: "<" >
    | <LE: "<=" >
    | <GE: ">=" >
// Depois no sintático, terá que ser adicionado como comando
    | <EQUAL: "=" >
    | <NE: "!=" >
    | <SC_OR: "or" >
    | <SC_AND: "and" >
    | <XOR_OP: "xor" >
| <END_SYMBOL : "$">
}

/*****************************************
IDENTIFICADORES
*****************************************/
TOKEN : { 
    < IDENTIFIER : ( ["a"-"z", "A"-"Z"] | "_" ) ( ["a"-"z", "A"-"Z"] | ["0"-"9"] | "_" )* > 
    | < CHAR : (["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
        | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" ) >
}

/*****************************************
MANIPULACAO DE NUMEROS
*****************************************/
TOKEN : {
    < INTEGER : ["0"-"9"] (["0"-"9"] | "_")* >
    | < FLOAT   : <INTEGER> <DOT> ["0"-"9"] (["0"-"9"] | "_")* >
    | < EXP     : (<INTEGER> | <FLOAT>) ("E" | "e") (<PLUS> | <MINUS>)? <INTEGER> >
}


TOKEN : {
    < BIN_NUMBER : "0b" (["0", "1"])+(["0", "1", "_"])* >
    | < OCT_NUMBER : "0t" (["0"-"7"])+(["0"-"7", "_"])* >
    | < DEC_NUMBER : "0d" <INTEGER> >
    | < HEX_NUMBER : "0x" (["0"-"9", "A"-"F"])+(["0"-"9", "A"-"F", "_"])* >
}

/*****************************************
MANIPULAÇÃO DE STRINGS
*****************************************/
TOKEN : {
    < STRINGLIT : <SIMPLESTRINGLIT> | <RAWSTRINGLIT> >
    | < SIMPLESTRINGLIT : <QUOTE>
    (
        ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
        | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
        "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
        "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
        | <BINARY>
        | <HEX2>
        | <HEX4>
        | <HEX8>
        | <ESCCHAR>)* <QUOTE> >
    | < ESCCHAR : <ESCLEAD> ( "n" | "r" | "t" | "\\" | "\"" | "\'" | "0" | "e" | "E" 
        | <BINARY> | <HEX2> | <HEX4> | <HEX8> ) >
| < BINARY : "\\b" (["0", "1"])+(["0", "1", "_"])* >//<BIN> >
| < HEX2 : "\\x" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < HEX4 : "\\u" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < HEX8 : "\\U" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < RAWSTRINGLIT : <DQRAWSTRING> | <BQRAWSTRING> | <VANSTRING> >
| < DQRAWSTRING : "´" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
    | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
    "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
    "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
    | <BINARY>
    | <HEX2>
    | <HEX4>
    | <HEX8>)+
"´" >
| <BQRAWSTRING : "\"\"\"" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
    | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
    "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
    "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
    | <BINARY>
    | <HEX2>
    | <HEX4>
    | <HEX8>)+
"\"\"\"" >
| <VANSTRING : "\'" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
    )+
"\'" >
}

/*************************
Statements Básicos
**************************/
TOKEN : {
    < WITHENTRY : <WITH> <ENTRY> >
    | < LABELSTMT : <LABEL> <STRINGLIT> >
}

/*************************
Branching
**************************/

TOKEN : {
    < ENDDEFIF      : <END> <IFDEF> >
}

/*******************************************************
MEUPHORIA GRAMMAR
*******************************************************/

void printError(Token t, String msg):
{
}
{
  {
    errors++;
    System.out.println("[" + t.beginLine + ", " + t.beginColumn + "] " + msg);
  }
}

void variables_declaration() :
{
    SemanticRoutines rSem; 
}
{
    {
        rSem = new SemanticRoutines();
    }

    ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier())? (VarDeclare(rSem) | ProcDeclare(rSem) | EnumDeclare(rSem) ) ) 
      )*
      <EOF>
}

      void VarDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        type = DataType(rSem) 

        IdentList(rSem, type)
      }

                  void IdentList(SemanticRoutines rSem, Type type) :
                  {
                    //int enum = 0;
                  }
                  {
                    Ident(rSem, type) 
                    // ?????????? corrigir para o enum
                    /*{
                      if(type == Type.Enum)
                        enum ++;
                    }*/

                    ( <COMMA> Ident(rSem, type) )* 
                  }

                        void Ident(SemanticRoutines rSem, Type type) :
                        {
                          Token t;
                        }
                        {
                           t = <IDENTIFIER> 
                           {
                              if(!checkDeclaration) {
                                  if (rSem.searchLevel(t.toString()) == null) {
                                    Symbol s = new Symbol(t.toString(),rSem.getLevel(),Category.Variable);
                                    s.setType(type);
                                    rSem.insert(s);
                                  }
                                  else {
                                    //Throw semantic exception
                                    printError(t, "Erro Semantico: Variavel '" + t.toString() + "' ja declarada.");
                                  }
                              }
                           }
                           (<EQUAL> Expression(rSem))?
                        }


      /* NAO SEI SE O ENUM EH ASSIM ????????? */
      void EnumDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        <ENUM> 
        {
          type = Type.Enum;
        }
        (EnumVal(rSem, type) | EnumType(rSem, type))
      }

            void EnumVal(SemanticRoutines rSem, Type type) :
            {}
            {
              IdentList(rSem, type)
            }

            void EnumType(SemanticRoutines rSem, Type type) :
            {}
            {
              <TYPE> IdentList(rSem, type) <END> <TYPE>
            }


      void ProcDeclare(SemanticRoutines rSem) : 
      {
        Token t, t2;
        Symbol proc = null;
        java.util.ArrayList<Symbol> par = new java.util.ArrayList<Symbol>();
        java.util.ArrayList<Type> return_parameters = null;//new java.util.ArrayList<Type>();
        int flag = 0;
        int a = 0;
        int tmp = 0;
      }
      {
        {
          if(_return_param!= null && !_return_param.isEmpty()) {
              return_parameters = new java.util.ArrayList<Type>();
              for(int count=0; count<_return_param.size(); count++)
                return_parameters.add(_return_param.get(count));

            _return_param.clear();
          }
          if(_return > 0) {
            tmp = _return;
            _return = 0;
          }
        }
        (t2 = <PROCEDURE> | t2 = <TYPE> | t2 = <FUNCTION>)
        t = <IDENTIFIER> 
        {
          if(!checkDeclaration) {
              if ( rSem.searchLevel(t.toString()) == null ) {
                proc = new Symbol(t.toString(), rSem.getLevel(), Category.Procedure);
                rSem.insert(proc);
                rSem.newLevel();
                flag = 1;
              }
              else {
                //Throw semantic exception
                printError(t, "Erro Semantico: Procedimento '" + t.toString() + "' ja declarado.");
              }
          }
        }

        <LPAREN> 
          ( 
              par = ParamList(rSem) 
              {
                if(proc != null)
                  proc.setParameters(par);
              }
          )? 

        <RPAREN> 
        ( stmblk(rSem) )* 

        <END> ProcedureType(rSem, t2)

        {

          if(proc != null) {
            proc.setReturnParameters(_return);
            proc.setReturnTypes(_return_param);
          }
          _return_param.clear();
          if(return_parameters != null) {
            for(int count=0; count<return_parameters.size(); count++)
              _return_param.add(return_parameters.get(count));

            return_parameters = null;
          }

          if(_return > 0) {
            if(t2.toString().equals("procedure") && !checkDeclaration)
              printError(t2, "Erro Semantico: Procedure nao pode retornar nenhum valor.");
            _return = tmp;
          }
          else if((t2.toString().equals("function") || t2.toString().equals("type") ) && !checkDeclaration)
            printError(t2, "Erro Semantico: " + t2.toString() + " nao retorna nenhum valor.");

          if (flag == 1) {

              if(proc!= null) {
                proc.setNPar(par.size());
                
                for (int i = 0; i < par.size(); i++)
                  rSem.insert(par.get(i));
              }
          }
          if(!checkDeclaration) {
            rSem.removeLastLevel();
          }
        }
      }

            void ProcedureType(SemanticRoutines rSem, Token procType) :
            {
              Token t;
            }
            {
              t = <PROCEDURE> | t = <FUNCTION> | t = <TYPE>
              {
                if(!t.toString().equals(procType.toString()) && !checkDeclaration)
                  printError(t, "Erro Sintático: Esperado fechamento de '" + procType.toString());
              }
            }


      java.util.ArrayList<Symbol> ParamList(SemanticRoutines rSem) :
      {
        Symbol s;
        java.util.ArrayList<Symbol> parList = new java.util.ArrayList<Symbol>();
      }
      {
        s = Parameter(rSem) 
        {
          parList.add(s);
        }

        (
            <COMMA> 
            s = Parameter(rSem) 
            {
              parList.add(s);
            }
        )*


        {
          return parList;
        }
      }

            Symbol Parameter(SemanticRoutines rSem) :
            {
              Type type;
              Token t;
            }
            {
              type = DataType(rSem) 
              t = <IDENTIFIER>
              {
                if (rSem.searchLevel(t.toString()) == null) {
                  Symbol s = new Symbol(t.toString(), rSem.getLevel(), Category.Parameter);
                  s.setType(type);
                  rSem.insert(s);
                  return s;
                }
                else {
                  if(!checkDeclaration)
                      printError(t, "Erro Semantico: Parâmetro '" + t.toString() + "' ja declarado.");
                  return null;
                }
              }
            }




void javacc_input() :
{
    Token t;
    SemanticRoutines rSem;
}
{
      {
        rSem = new SemanticRoutines();
      }
    
      ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier())? ( VarDeclare(rSem) | EnumDeclare(rSem) | ProcDeclare(rSem) ) )
      )*
      <EOF>

      {
        if ( errors != 0 ) {
          System.out.println("Análise encontrou " + errors + " erro(s).");
        } 
        else {
          System.out.println("Análises léxica, sintática e semântica concluídas com sucesso!");
        }

      }
}

      int stmblk(SemanticRoutines rSem) :
      {
        int a = 0;
      }
      {
          ( a = statement(rSem) ) { return a; }
          | <EOL> { return a; }
      }

      int statement(SemanticRoutines rSem) :
      {
        Token t;
        int a = 0;
      }
      {
            Flow(rSem) { return a; }
          | Loop(rSem) { return a; }
          | Branch(rSem) { return a; }
          | (a = Return(rSem) ) { return a; }
          | LOOKAHEAD(2) (t = <IDENTIFIER>) (Assignment(rSem,t) | Call(rSem,t))  { return a; }
          | (ScopeModifier())? (VarDeclare(rSem) | ProcDeclare(rSem) | EnumDeclare(rSem) )  { return a; }
          | Print(rSem) { return a; }
          
      }

void Print(SemanticRoutines rSem) :
{}
{
  <PRINT> Expression(rSem)
}

            void Flow(SemanticRoutines rSem) :
            {}
            {
              ( <BREAK> (<INTEGER>)? | <CONTINUE> | <RETRY> | <EXIT> | <FALLTHRU> ) (<STRINGLIT>)?
            }


void Loop(SemanticRoutines rSem) :
{}
{
  (
    ( ForStatement(rSem) | WhileStatement(rSem) | LoopStatement(rSem) )
    {
      if(!checkDeclaration) {
        rSem.removeLastLevel();
      }
    }
  )
  | <GOTO> <LABELSTMT>
}

      void ForStatement(SemanticRoutines rSem) :
      {}
      {
        <FOR> ForIDX(rSem) (<LABELSTMT>)? <DO> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))* <END> <FOR> 
      }

      void ForIDX(SemanticRoutines rSem) :
      {}
      {
          // check if the expressions have the same type as the identifier ????
          <IDENTIFIER> <EQUAL> Expression(rSem) <TO> Expression(rSem) (<BY> Expression(rSem))?

      }

      void WhileStatement(SemanticRoutines rSem) :
      {
        Token t;
        java.util.ArrayList<Type> type;
      }
      {
        t = <WHILE> 
        type = Expression(rSem) 
        {
          if(type.size() != 1 && !checkDeclaration)
            printError(t, "Erro Semantico: A expressão do " + t.toString() + " retorna nenhum ou mais resultados." );
          else if(type.get(0) != Type.Boolean && !checkDeclaration)
            printError(t, "Erro Semantico: A condição do " + t.toString() + " deve ser do tipo boolean" );
        }
        (<WITHENTRY>)? (<LABELSTMT>)? <DO> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))* (EntryStatement(rSem))? <END> <WHILE>
      }

      void LoopStatement(SemanticRoutines rSem) :
      {
        java.util.ArrayList<Type> type;
        Token t;
      }
      {
        <LOOP> (<WITHENTRY>)? (<LABELSTMT>)? <DO> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))* (EntryStatement(rSem))? 

        t = <UNTIL> 
        type = Expression(rSem) 
        {
          if(type.size() != 1 && !checkDeclaration)
            printError(t, "Erro Semantico: A expressão do " + t.toString() + " retorna nenhum ou mais resultados." );
          else if(type.get(0) != Type.Boolean && !checkDeclaration)
            printError(t, "Erro Semantico: A condição do " + t.toString() + " deve ser do tipo boolean" );
        }

        (<EOL>)* <END> <LOOP>
      }

            void EntryStatement(SemanticRoutines rSem) :
            {}
            {
              <ENTRY> (stmblk(rSem))* 
            }

void Branch(SemanticRoutines rSem) :
{}
{
    IfStatement(rSem) | SwitchStatement(rSem) | IfDefStatement(rSem)
}

void IfStatement(SemanticRoutines rSem) :
{}
{
    IfTest(rSem) 
    {
      if(!checkDeclaration) {
        rSem.removeLastLevel();
      }
    }

    (
      ElsifStatement(rSem)
      {
        if(!checkDeclaration) {
          rSem.removeLastLevel();
        }
      }
    )* 


    (
      ElseStatement(rSem)
      {
        if(!checkDeclaration) {
          rSem.removeLastLevel();
        }
      }
    )? 

    <END> <IF>
}

      void IfTest(SemanticRoutines rSem) :
      {
        Token t;
        java.util.ArrayList<Type> type;
      }
      {
        t = <IF> 
        type = Expression(rSem) 
        {
          if(type.size() != 1 && !checkDeclaration)
            printError(t, "Erro Semantico: A expressão do " + t.toString() + " retorna nenhum ou mais resultados." );
          else if(type.get(0) != Type.Boolean && !checkDeclaration)
            printError(t, "Erro Semantico: A condição do " + t.toString() + " deve ser do tipo boolean" );
        }
        (<LABELSTMT>)? <THEN> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))* 
      }

      void ElsifStatement(SemanticRoutines rSem) :
      {
        Token t;
        java.util.ArrayList<Type> type;
      }
      {
        t = <ELSIF> 
        type = Expression(rSem) 
        {
          if(type.size() != 1 && !checkDeclaration)
            printError(t, "Erro Semantico: A expressão do " + t.toString() + " retorna nenhum ou mais resultados." );
          else if(type.get(0) != Type.Boolean && !checkDeclaration)
            printError(t, "Erro Semantico: A condição do " + t.toString() + " deve ser do tipo boolean" );
        }
        <THEN> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))*
      }

      void ElseStatement(SemanticRoutines rSem) :
      {}
      {
        <ELSE> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))*
      }


void IfDefStatement(SemanticRoutines rSem) :
{}
{
    IfDefTest(rSem)
    {
      if(!checkDeclaration) {
        rSem.removeLastLevel();
      }
    } 

    ( 
      ElsDefIfStatement(rSem) <LABELSTMT> 
      {
        if(!checkDeclaration) {
          rSem.removeLastLevel();
        }
      }
    )? 

    ( 
      ElsDefStatement(rSem)
      {
        if(!checkDeclaration) {
          rSem.removeLastLevel();
        }
      }
    )? 

    <ENDDEFIF>
}

      void IfDefTest(SemanticRoutines rSem) :
      {}
      {
        // check if it is not necessary operations on the identifiers ??????
        <IFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> 
        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))*
      }

      void ElsDefIfStatement(SemanticRoutines rSem) :
      {}
      {
        // check if it is not necessary operations on the identifiers ??????
        <ELSEIFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))*
      }

      void ElsDefStatement(SemanticRoutines rSem) :
      {}
      {
        <ELSEDEF> 

        {
          if(!checkDeclaration) {
            rSem.newLevel();
          }
        }

        (stmblk(rSem))*
      }

void SwitchStatement(SemanticRoutines rSem) :
{}
{
  SwitchTest(rSem) 

  CaseStatement(rSem) 
  {
    if(!checkDeclaration) {
      rSem.removeLastLevel();
    }
  }

  (LOOKAHEAD(2) 
      CaseStatement(rSem)
      {
        if(!checkDeclaration) {
          rSem.removeLastLevel();
        }
      }
  )* 

  (
    {
      if(!checkDeclaration) {
        rSem.newLevel();
      }
    }
    <ELSE> (stmblk(rSem))* 
    {
      if(!checkDeclaration) {
        rSem.removeLastLevel();
      }
    }
  )? 

  <END> <SWITCH>
}

      void SwitchTest(SemanticRoutines rSem) :
      {}
      {
          <SWITCH> Expression(rSem) ((<WITH> | <WITHOUT>) <FALLTHRU>)? (<LABELSTMT>)? <DO> (<EOL>)?
      }

void CaseStatement(SemanticRoutines rSem) :
{}
{
  // check if the switchTest expression has the same type as the caseList ??????
<CASE> CaseList(rSem) <THEN> 
  {
    if(!checkDeclaration) {
      rSem.newLevel();
    }
  }
(stmblk(rSem))* 
}

      void CaseList(SemanticRoutines rSem) :
      {}
      {
          Expression(rSem) (<COMMA> Expression(rSem))* 
      }

// MUDAR AINDA ??????????????
void Assignment(SemanticRoutines rSem, Token identifier) :
{
  Symbol var;
}
{
    {
      var = rSem.searchLevel(identifier.toString());
      if(var == null && !checkDeclaration)
        printError(identifier, "Erro Semantico: Variável " + identifier.toString() + " não declarada.");
    }
    AssignmentMulti(rSem, identifier) | AssignmentWihOp(rSem, identifier)
}

      void AssignmentMulti(SemanticRoutines rSem, Token identifier) :
      {
        Token t;
        Type tp;
        Symbol s;
        //Type tp1 = null, tp2 = null;
        java.util.ArrayList<Type> tp1 = new java.util.ArrayList<Type>();
        java.util.ArrayList<Type> tp2 = new java.util.ArrayList<Type>();
        java.util.ArrayList<Type> tmp = new java.util.ArrayList<Type>();

        int var = 1, exp = 0;
      }
      {
          {
            call = null;
            if(!checkDeclaration) { 
              s = rSem.searchLevel(identifier.toString());
              tp = s.getType();
              tp1.add(tp);
            }
          }
          (Variable(rSem, identifier))? 
          (
            <COMMA> t = <IDENTIFIER> (Variable(rSem, identifier))? 
            {
              var++;
              s = rSem.searchLevel(t.toString());
              tp = s.getType();
              tp1.add(tp);
            }
          )? 
          t = <EQUAL> 
          
          // teria que pegar ou retornar o token da expressão para saber se é ou não uma função.
          tmp = Expression(rSem) 

          {
            if(!tmp.isEmpty() && !checkDeclaration) {
              for(int i = 0; i < tmp.size(); i++)
                tp2.add(tmp.get(i));
              tmp.clear();
            }

            if(call != null) {
              Symbol c = rSem.search(call.toString());
              if(c != null && c.getCategory() == Category.Procedure) {
                exp += c.getReturnParameters();
              }
              else
                exp = 1;
            }
            else
              exp = 1;
          }
          (
            <COMMA> tmp = Expression(rSem)
            {
              if(!tmp.isEmpty() && !checkDeclaration) {
                for(int i = 0; i < tmp.size(); i++)
                  tp2.add(tmp.get(i));
                tmp.clear();
              }

              if(call != null) {
                Symbol c = rSem.search(call.toString());
                if(c != null && c.getCategory() == Category.Procedure) {
                  exp += c.getReturnParameters();
                }
                else
                  exp++;
              }
              else
                exp++;
            }
          )?
          {
            if(var != exp && !checkDeclaration) {
              printError(t, "Erro Semantico: Quantidade diferente de parametros na atribuicao de variaveis.");
            }
            else if(!checkDeclaration){
              // check if the types are the same ????????
              for(int i = 0; i < tp1.size(); i++) {
                if(tp1.get(i) != tp2.get(i) && !rSem.checkAtom(tp1.get(i), tp2.get(i)) ) {
                  printError(t, "Erro Semantico: Tipos diferentes na atribuição de variáveis. " + tp1.get(i).toString() + " e " + tp2.get(i).toString());
                }
              }
            }
          }
      }

      void AssignmentWihOp(SemanticRoutines rSem, Token identifier) :
      {}
      {
          (<PLUS> | <MINUS> | <SLASH> | <STAR> | <CONCAT> ) <EQUAL> Expression(rSem) 
          {
            
            // verificar os tipos do identifier e da expressão, para saber se pode fazer a atribuição ????????
          }
      }

int Return(SemanticRoutines rSem) :
{
  Token t;
  java.util.ArrayList<Type> type = null;
  int i = 1;
  java.util.ArrayList<Type> tmp = new java.util.ArrayList<Type>();
}
{
    t = <RETURN> 
    Expression(rSem) 
    (
      <COMMA> 
      type = Expression(rSem)
      {
        i++;
        // adicionar na lista 
        for(int j = 0; j < type.size(); j++)
            tmp.add(type.get(j));
      }
    )*

    {
      if(_return > 0 && _return != i && !checkDeclaration) {
        printError(t, "Erro Semantico: Quantidade de parametros de retorno diferentes.");
      }
      else if(_return == 0) {
        _return = i;

        if(_return_param == null)
          _return_param = new java.util.ArrayList<Type>();

        for(int count=0; count<tmp.size(); count++)
            _return_param.add(tmp.get(count));
      }
      else if(!checkDeclaration){
        for(int count=0; count<tmp.size(); count++) {
          if(tmp.get(count) != _return_param.get(count))
            printError(t, "Erro Semantico: Tipos de retornos diferentes.");     
        }
      }

      return 1;
    }
}


void Call(SemanticRoutines rSem, Token t) :
{
  Symbol proc = null;
  java.util.ArrayList<Type> par = new java.util.ArrayList<Type>();
}
{
    <LPAREN> 
      (
        par = ArgList(rSem)
      )? 
    <RPAREN>

        {
            if(checkDeclaration) {
                  proc = rSem.search(t.toString());

                  if (proc != null) {
                    
                    int analisePar = proc.verifyParameters(par);

                    if (analisePar == 1 ) {
                      printError(t, "Erro semantico: Procedimento '" + t + "' não declarado.");
                    } else if (analisePar == 2)
                      printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com numero de parametros invalidos.");
                    else if (analisePar == 3)
                      printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com tipo de parametros invalidos.");
                    else {
                      //DO SOMETHING
                      // está correto
                    }

                  }
                  else {
                    printError(t, "Erro semantico: Procedimento '" + t.toString() + "' não declarado.");
                  }
            }
        }
        
}


      java.util.ArrayList<Type> ArgList(SemanticRoutines rSem) :
      {
        java.util.ArrayList<Type> type;
        java.util.ArrayList<Type> parList = new java.util.ArrayList<Type>();
      }
      {
        type = Expression(rSem)
        {
          for(int i = 0; i < type.size(); i++)
            parList.add(type.get(i));
          //parList.add(type);
        }

        (
            <COMMA> 
            type = Expression(rSem)
            {
              for(int i = 0; i < type.size(); i++)
                parList.add(type.get(i));
              //parList.add(type);
            }
        )*


        {
          return parList;
        }
      }


/************************************************************
SEQUENCIA
************************************************************/

void Sequence(SemanticRoutines rSem) :
{
  //int tam;
}
{
    // Professora simplificou para que coloque tudo dentro da expressão
    <LBRACE> ( LOOKAHEAD(2) <END_SYMBOL> | Object(rSem) (LOOKAHEAD(2) <COMMA> Object(rSem))* (<COMMA> <END_SYMBOL>)? )? <RBRACE> 
}


void Object(SemanticRoutines rSem) :
{}
{
    Sequence(rSem) | Atom(rSem) | <BIN_NUMBER> | <OCT_NUMBER> | <DEC_NUMBER> | <HEX_NUMBER> | <IDENTIFIER> | <STRINGLIT>
}


/************************************************************
EXPRESSÕES
************************************************************/

java.util.ArrayList<Type> Expression(SemanticRoutines rSem) :
{
  java.util.ArrayList<Type> tp = new java.util.ArrayList<Type>();
  java.util.ArrayList<Type> tp2 = new java.util.ArrayList<Type>();
  java.util.ArrayList<Type> type = new java.util.ArrayList<Type>();
}
{
    (
      /* The code has to be readapt to accept the changes for sequence calculations ??????
       Sequências e operadores {{ "jon", "smith" }, 52389, 97.25} => OK
        x = { {1, 2, 3} + {-1, 0, 1}, {4, 5, 6} + {-1, 0, 1} } => OK

        w = ({1, 0, 0, 1}) and ({1, 1, 1, 0}) => só funciona com parênteses w = not ({1, 5, -2, 0, 0}) => só funciona com parênteses
        w = ({1, 2, 3}) = ({1, 2, 4}) => só funciona com parênteses

        x = {apple, orange*2, {1,2,3}, 99/4+foobar} => OK*/

      //Sequence(rSem)
        <LBRACE> ( LOOKAHEAD(2) <END_SYMBOL> | tp = Expression(rSem) 
        /*{
          if(!tp.isEmpty()) {
            for(int i = 0; i < tp.size(); i++)
              tp2.add(tp.get(i));
          }
          tp.clear();
        }*/
        (LOOKAHEAD(2) <COMMA> 
          tp = Expression(rSem)
          /*{
            if(!tp.isEmpty()) {
              for(int i = 0; i < tp.size(); i++)
                tp2.add(tp.get(i));
            }
            tp.clear();
          }*/
        )* (<COMMA> <END_SYMBOL>)? )? <RBRACE> 
      {
        //System.out.println(tp2);
        type.add(Type.Sequence);
        return type;
      }
    )
      | 
    (
      type = Expression00(rSem)
      {
        return type;
      }
    )
}

java.util.ArrayList<Type> Expression00(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp1, tp2, tmp = new java.util.ArrayList<Type>();
}
{
    tp1 = Expression01(rSem) 
    ( 
      (t = <SC_AND> | t = <SC_OR> | t = <XOR_OP>) 
      tp2 = Expression01(rSem) 
      {
        if(t != null) {
          // check if the expressions are sequences with different sizes ???????
          // if tp1 or tp2 sizes are more than one, then they are sequences
          if((tp1.get(0) == Type.Sequence && tp2.get(0) == Type.Sequence) && tp1.size()!= tp2.size())
              printError(t, "Erro Semantico: Sequencias de tamanhos diferentes.");
          tmp.add(Type.Boolean);
          return tmp;
        }   
      }
    )?
    {
      //if(t != null) {
        // check if the expressions are sequences with different sizes ???????
        //return Type.Boolean;
      //}
      //else
        return tp1;
    }
}

java.util.ArrayList<Type> Expression01(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp1, tp2, tmp = new java.util.ArrayList<Type>();
}
{
    tp1 = Expression02(rSem) 
    ( 
      ( t = <LT> | t = <GT> | t = <LE> | t = <GE> | t = <EQUAL> | t = <NE> )
      tp2 = Expression02(rSem)
      {
        if(t != null) {
            // check if the expressions are sequences with different sizes ???????
            // if tp1 or tp2 sizes are more than one, then they are sequences
            if((tp1.get(0) == Type.Sequence && tp2.get(0) == Type.Sequence) && tp1.size()!= tp2.size())
                printError(t, "Erro Semantico: Sequencias de tamanhos diferentes.");
            tmp.add(Type.Boolean);
            return tmp;
          }  
      } 
    )*
    {
        
        return tp1;
    }
}

java.util.ArrayList<Type> Expression02(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp1, tp2, tmp=new java.util.ArrayList<Type>();
}
{
    tp1 = Expression03(rSem) 
    ( 
      ( t = <CONCAT> )
      tp2 = Expression03(rSem) {
        if(t != null) {
            // tudo se concatena e vira sequencia (lembrar que sequencia é o Arr > 1)
            // lembrar de juntar arraylist tp1 e tp2(adicionar tp2 em tp1)
            tmp.add(Type.Sequence);
            for(int count=0; count<tp1.size(); count++)
              tmp.add(tp1.get(count));
            for(int count=0; count<tp2.size(); count++)
              tmp.add(tp2.get(count));

            return tmp;
          }  
      }
    )*
    {
        return tp1;
    }
}

java.util.ArrayList<Type> Expression03(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp1, tp2, tmp=new java.util.ArrayList<Type>();
  int value1=0, value2=0;
}
{
    tp1 = Expression04(rSem) 
    ( 
      ( t = <PLUS> | t = <MINUS> )
      tp2 = Expression04(rSem) 
      {
        if(t != null) {
            // check if the expressions are sequences with different sizes ???????
            // if tp1 or tp2 sizes are more than one, then they are sequences
            if((tp1.get(0) == Type.Sequence && tp2.get(0) == Type.Sequence) && tp1.size()!= tp2.size())
                printError(t, "Erro Semantico: Sequencias de tamanhos diferentes.");

            value1=0;
            value2=0;

            if(tp1.get(value1) == tp2.get(value2)) tmp.add(tp1.get(value1));
            else if(tp1.get(value1) == Type.Sequence || tp2.get(value2) == Type.Sequence ) tmp.add(Type.Sequence);
            else if(tp1.get(value1) == Type.Object || tp2.get(value2) == Type.Object ) tmp.add(Type.Object);
            else if(tp1.get(value1) == Type.Atom || tp2.get(value2) == Type.Atom ) tmp.add(Type.Atom);
            else if(tp1.get(value1) == Type.Int || tp2.get(value2) == Type.Int ) tmp.add(Type.Int);
            else printError(t, "Erro Semantico: Tipo invalido.");
            
            return tmp;

          }  
      } 
    )*
    {

      // check the matching types ?????????????
      return tp1;
    }
}

java.util.ArrayList<Type> Expression04(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp1, tp2, tmp=new java.util.ArrayList<Type>();
  int value1=0, value2=0;
}
{
    tp1 = Expression05(rSem) 
    ( 
      ( t = <STAR> | t = <SLASH> )
      tp2 = Expression05(rSem) 
      {
        if(t != null) {
            // check if the expressions are sequences with different sizes ???????
            // if tp1 or tp2 sizes are more than one, then they are sequences
            if((tp1.get(0) == Type.Sequence && tp2.get(0) == Type.Sequence) && tp1.size()!= tp2.size())
                printError(t, "Erro Semantico: Sequencias de tamanhos diferentes.");

            value1=0;
            value2=0;

            if(tp1.get(value1) == tp2.get(value2)) tmp.add(tp1.get(value1));
            else if(tp1.get(value1) == Type.Sequence || tp2.get(value2) == Type.Sequence ) tmp.add(Type.Sequence);
            else if(tp1.get(value1) == Type.Object || tp2.get(value2) == Type.Object ) tmp.add(Type.Object);
            else if(tp1.get(value1) == Type.Atom || tp2.get(value2) == Type.Atom ) tmp.add(Type.Atom);
            else if(tp1.get(value1) == Type.Int || tp2.get(value2) == Type.Int ) tmp.add(Type.Int);
            else printError(t, "Erro Semantico: Tipo invalido.");
            
            return tmp;

          }  
      } 
    )*
    {

      // check the matching types ?????????????
      return tp1;
    }
}

java.util.ArrayList<Type> Expression05(SemanticRoutines rSem) :
{
  Token t = null;
  java.util.ArrayList<Type> tp = null;
}
{
    (t = <PLUS> | t = <MINUS> | t = <NOT_OP>)? 
    tp = Expression06(rSem)
    {
      return tp;
    }
}

java.util.ArrayList<Type> Expression06(SemanticRoutines rSem) :
{
  Token t;
  Symbol var = null;
  java.util.ArrayList<Type> tp = new java.util.ArrayList<Type>();
}
{
      Atom(rSem) {  tp.add(Type.Atom); return tp; }

    | <STRINGLIT> { tp.add(Type.Sequence); return tp; }

    | (<LPAREN> tp = Expression(rSem) <RPAREN>) { return tp; }

    | (t = <IDENTIFIER>) (Call(rSem, t) | Variable(rSem, t))? 
      { // search the variable and return its type ?????? 
        call = t;
        // check if the variable is declared
        var = rSem.searchLevel(t.toString());
        Symbol var2 = rSem.search(t.toString());
        if(var == null) {
          if(!checkDeclaration)
            printError(t, "Erro Semantico: Variável " + t.toString() + " não declarada.");
          tp.add(Type.NotDeclared);
          return tp;
        }
        else {
          if(var.getCategory() == Category.Procedure)
            return var.getReturnTypes();
          else {
            tp.add(var.getType());
            return tp;
          }
        }
      }

}










void Variable(SemanticRoutines rSem, Token t) :
{}
{
    <LBRACKET> Expression(rSem) (Slice(rSem, t) | Subscripting(rSem, t))
}

void Slice(SemanticRoutines rSem, Token t) :
{
  Type type;
}
{
    // check if upper limit is inferior than lower limit ???????
    <SLICE> ( Expression(rSem) | <END_SYMBOL>) <RBRACKET> 
      (
        <LBRACKET> Expression(rSem) <SLICE> ( Expression(rSem) | <END_SYMBOL>) <RBRACKET>
      )*

    {
      // check if the expressions are integers numbers ???????

    }
}

void Subscripting(SemanticRoutines rSem, Token t) :
{}
{
    <RBRACKET> ( Index(rSem) )*
}

                  void Index(SemanticRoutines rSem) :
                  {}
                  {
                    // check if it is integer and smaller than the creation index ???????
                    // in the creation, save the index number ???????
                    <LBRACKET> Expression(rSem) <RBRACKET>
                    {

                    }
                  }


/*****************************************
DATA TYPE
*****************************************/

void ScopeModifier() :
{}
{
    <GLOBAL> | <PUBLIC> | <EXPORT> | <OVERRIDE>
}

Type DataType(SemanticRoutines rSem) :
{
  Token t;
  Type tp;
}
{
  t = <IDENTIFIER>
  {
      tp = null;
      if(t.toString().equals("atom"))
          tp = Type.Atom;
      else if(t.toString().equals("integer"))
          tp = Type.Int;
      else if(t.toString().equals("sequence"))
          tp = Type.Sequence;
      else if(t.toString().equals("object"))
          tp = Type.Object;
      else if(t.toString().equals("constant"))
          tp = Type.Constant;
      else if(t.toString().equals("boolean"))
          tp = Type.Boolean;
      else if(!checkDeclaration)
        printError(t, "Erro Semantico: Tipo " + t.toString() + " nao existe.");

      return tp;
  }
}

void Real(SemanticRoutines rSem) :
{}
{
    <FLOAT> | <EXP>
}

void Atom(SemanticRoutines rSem) :
{}
{
    <INTEGER> | Real(rSem)
}
