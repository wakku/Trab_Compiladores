/* **********************************************************************
                          ANALISADOR LÉXICO
************************************************************************

Integrantes: 
  Caio Gomes                  7239072
  Diego Gomes                 7656467
  Fernando Cury Gorodscy      7152354
  Roberty Manzini Bertolo     7573399
  Vanessa Apolinário Lima     7239256

Documento:
  Codigo fonte

Nome:
  MeuPhoria

************************************************************************/


/*****************************************
                Opções
*****************************************/
options {
  STATIC = false;
  DEBUG_LOOKAHEAD = false;
  COMMON_TOKEN_ACTION = true ;
}

/*****************************************
    Inicialização do Analisador Léxico
*****************************************/
PARSER_BEGIN(Meuphoria)

/* MeuPhoria Parser */
class Meuphoria {

  private static int errors = 0;

  // Processa o código e gera a tabela de tokens
  public void processa() throws ParseException, TokenMgrError{
    Token t;
    String nomeToken;
    do {
        // Pega o próximo token gerado pelo Léxico.
        t = getNextToken();
        if(t.kind == IDENTIFIER) {
        // Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
        	if(t.image.length() > 30)
            	throw new TokenMgrError();
        }
        // Pega o proximo token do tipo t.kind
        nomeToken = tokenImage[t.kind];
        // Seta a localização do token
        String location = "@(" + t.beginLine + ", " + t.beginColumn + ")";
        // Imprime as informações do token. Se for EOF não imprime image, pois ela não existe.
        if(t.kind == EOL)
			System.out.println(String.format("%-15s %-20s <EOL>", location, nomeToken));
        else
			System.out.println(String.format("%-15s %-20s %s", location, nomeToken, t.image));
    } while (!(nomeToken.equals("<EOF>"))); // Termina o loop se EOF
    System.out.println(String.format("%s", t.image));
  }

  /** Main entry point. */
  public static void main(String args[]) {
    try
    {
      java.io.InputStream tmp = System.in;

      java.io.InputStreamReader is = new java.io.InputStreamReader(tmp);
      java.lang.StringBuilder sb=new java.lang.StringBuilder();
      java.io.BufferedReader br = new java.io.BufferedReader(is);
      try {
        String read = br.readLine();

        while(read != null) {
            //System.out.println(read);
            sb.append(read + "\n");
            read =br.readLine();

        }
      }
      catch(java.io.IOException e) {
          System.out.println(e.getMessage());
      }

      //System.out.println(sb.toString());

      // Define o analisador sintatico de acordo com a entrada do sistema
      //Meuphoria analisadorSintatico = new Meuphoria(System.in);
      Meuphoria analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

      // Roda o loop de processamento enquanto não encontrar EOF
      //analisadorlexico.processa();
      // Processamento finalizado
      //System.out.println("Analisado com sucesso!");

      //analisadorSintatico.javacc_input();
      analisadorSintatico.variables_declaration();

      analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

      //analisadorSintatico.javacc_input();
      //System.out.println("SUCESSO!");
    }
    catch(ParseException e)
    {
      System.out.println(e.getMessage());
        System.out.println("Ocorreu uma excecao!");
    }
    catch(TokenMgrError e)
    {
        System.out.println(e.getMessage());
        System.out.println("Existem erros no codigo! Por favor, verifica-los.");
    }
  }
}
PARSER_END(Meuphoria)



TOKEN_MGR_DECLS : { 
	
	//Ação executada para cada Token encontrado
	void CommonTokenAction(Token t) {
		if(t.kind == IDENTIFIER) {
        	// Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
        	if(t.image.length() > 30)
            	throw new TokenMgrError();
        	}
	}
}



/*****************************************
                SKIP
*****************************************/
SKIP : { " " | "\t" | "\r" }

/* Skip Comentários de linha e de bloco */
SKIP :
{
  "/*" : WithinComment
  | <COMENTARIO_INICIAL : "#" (~["\n","\r"])*  >
  | <COMENTARIO_LINHA: "--" (~["\n","\r"])* >
}

<WithinComment> SKIP :
{
  "*/" : DEFAULT
}

<WithinComment> MORE :
{
  <~[]>
}

/*****************************************
              TERMINAIS
*****************************************/
TOKEN : {
  < EOL : "\n" >
}

/*****************************************
          PALAVRAS RERSERVADAS
*****************************************/
TOKEN : {
    <CASE :	"case">
  | <DO : "do">
  | <END : "end">
  | <EXPORT : "export">
  | <GLOBAL : "global">
  | <INCLUDE : "include">
  | <PUBLIC : "public">
  | <SWITCH : "switch">
  | <UNTIL : "until">
  | <AS : "as">
  | <CONSTANT : "constant">
  | <ELSE : "else">
  | <ENTRY : "entry">
  | <FALLTHRU : "fallthru">
  | <GOTO : "goto">
  | <LABEL : "label">
  | <RETRY : "retry">
  | <THEN : "then">
  | <WHILE : "while">
  | <BREAK : "break">
  | <CONTINUE : "continue">
  | <ELSEDEF : "elsedef">
  | <ENUM : "enum">
  | <IF : "if">
  | <LOOP : "loop">
  | <OVERRIDE : "override">
  | <RETURN : "return">
  | <TO : "to">
  | <WITH : "with">
  | <BY : "by">
  | <DEPRECATE : "deprecate">
  | <ELSIF : "elsif">
  | <EXIT : "exit">
  | <FUNCTION : "function">
  | <IFDEF : "ifdef">
  | <NAMESPACE : "namespace">
  | <PROCEDURE : "procedure">
  | <ROUTINE : "routine">
  | <TYPE : "type">
  | <WITHOUT : "without">
  | <PROFILE : "profile">
  | <PROFILE_TIME : "profile_time">
  | <TRACE : "trace">
  | <BATCH : "batch">
  | <TYPE_CHECK : "type_check">
  | <INDIRECT_INCLUDES : "indirect_includes">
  | <INLINE : "inline">
  | <WARNING : "warning">
  | <SAVE : "save">
  | <RESTORE : "restore">
  | <STRICT : "strict">
  | <ELSEIFDEF : "elsifdef">
  | <FOR : "for">
}

/*****************************************
              SEPARADORES
*****************************************/
TOKEN : { 
    <LPAREN: "(" >
  | <RPAREN: ")" >
  | <LBRACE: "{" >
  | <RBRACE: "}" >
  | <LBRACKET: "[" >
  | <RBRACKET: "]" >
  | <SEMICOLON: ";" >
  | <COMMA: "," >
  | <DOT: "." >
  | <#SINGLE_QUOTE: "\'" >
  | <SLICE: ".." >
  | <#QUOTE: "\"">
  | <#TRIPLE_QUOTE: "\"\"\"">
  | <COLON : ":">
}

/*****************************************
              OPERADORES
*****************************************/
TOKEN : {
  <NOT_OP: "not" >
  | <PLUS: "+" >
  | <MINUS: "-" >
  | <STAR: "*" >
  | <SLASH: "/" >
  | <ESCLEAD: "\\">
  | <CONCAT: "&" >
  | <GT: ">" >
  | <LT: "<" >
  | <LE: "<=" >
  | <GE: ">=" >
  // Depois no sintático, terá que ser adicionado como comando
  | <EQUAL: "=" >
  | <NE: "!=" >
  | <SC_OR: "or" >
  | <SC_AND: "and" >
  | <XOR_OP: "xor" >
  | <QMARK : "?"> // print command
  | <END_SYMBOL : "$">
}

/*****************************************
        VARIAVEIS PRE-DEFINIDAS
*****************************************
TOKEN : {
    < ATOM      : "atom" >
  | < INT       : "integer" >
  | < SEQUENCE  : "sequence" >
  | < OBJECT    : "object" >
}

/*****************************************
            IDENTIFICADORES
*****************************************/
TOKEN : { 
      < IDENTIFIER : ( ["a"-"z", "A"-"Z"] | "_" ) ( ["a"-"z", "A"-"Z"] | ["0"-"9"] | "_" )* > 
    | < CHAR : (["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
                | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" ) >
}

/*****************************************
        MANIPULACAO DE NUMEROS
*****************************************/
TOKEN : {
    < INTEGER : ["0"-"9"] (["0"-"9"] | "_")* >
  | < FLOAT   : <INTEGER> <DOT> ["0"-"9"] (["0"-"9"] | "_")* >
  | < EXP     : (<INTEGER> | <FLOAT>) ("E" | "e") (<PLUS> | <MINUS>)? <INTEGER> >
}


TOKEN : {
    < BIN_NUMBER : "0b" (["0", "1"])+(["0", "1", "_"])* >
  | < OCT_NUMBER : "0t" (["0"-"7"])+(["0"-"7", "_"])* >
  | < DEC_NUMBER : "0d" <INTEGER> >
  | < HEX_NUMBER : "0x" (["0"-"9", "A"-"F"])+(["0"-"9", "A"-"F", "_"])* >
}

/*****************************************
        MANIPULAÇÃO DE STRINGS
*****************************************/
TOKEN : {
  < STRINGLIT : <SIMPLESTRINGLIT> | <RAWSTRINGLIT> >
  | < SIMPLESTRINGLIT : <QUOTE>
                (
                ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
                | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
                  "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
                  "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
                | <BINARY>
                | <HEX2>
                | <HEX4>
                | <HEX8>
                | <ESCCHAR>)* <QUOTE> >
  | < ESCCHAR : <ESCLEAD> ( "n" | "r" | "t" | "\\" | "\"" | "\'" | "0" | "e" | "E" 
    | <BINARY> | <HEX2> | <HEX4> | <HEX8> ) >
  | < BINARY : "\\b" (["0", "1"])+(["0", "1", "_"])* >//<BIN> >
  | < HEX2 : "\\x" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
  | < HEX4 : "\\u" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
  | < HEX8 : "\\U" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
  | < RAWSTRINGLIT : <DQRAWSTRING> | <BQRAWSTRING> | <VANSTRING> >
  | < DQRAWSTRING : "´" 
                (
                ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
                | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
                  "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
                  "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
                | <BINARY>
                | <HEX2>
                | <HEX4>
                | <HEX8>)+
                "´" >
  | <BQRAWSTRING : "\"\"\"" 
                  (
                ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
                | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
                  "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
                   "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
                | <BINARY>
                | <HEX2>
                | <HEX4>
                | <HEX8>)+
                  "\"\"\"" >
  | <VANSTRING : "\'" 
                  (
                ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
                   )+
                  "\'" >
}

/*************************
    Statements Básicos
**************************/
TOKEN : {
    < WITHENTRY : <WITH> <ENTRY> >
  | < LABELSTMT : <LABEL> <STRINGLIT> >
}

/*************************
    Branching
**************************/

TOKEN : {
    < ENDDEFIF      : <END> <IFDEF> >
}

/*******************************************************
                MEUPHORIA GRAMMAR
*******************************************************/

void printError(Token t, String msg):
{
}
{
  {
    errors++;
    System.out.println("[" + t.beginLine + ", " + t.beginColumn + "] " + msg);
  }
}

void variables_declaration() :
{
    SemanticRoutines rSem; 
}
{
    {
        rSem = new SemanticRoutines();
    }

    ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier())? (VarDeclare(rSem) | ProcDeclare(rSem) | EnumDeclare(rSem) ) ) 
      )*
      <EOF>

      {
        if ( errors != 0 ) {
          System.out.println("Análise encontrou " + errors + " erro(s).");
        } 
        else {
          System.out.println("Análises léxica, sintática e semântica concluídas com sucesso!");
        }
      }
}


      void VarDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        type = DataType() 

        IdentList(rSem, type)
      }

                  void IdentList(SemanticRoutines rSem, Type type) :
                  {}
                  {
                    Ident(rSem, type) ( <COMMA> Ident(rSem, type) )* 
                  }

                        void Ident(SemanticRoutines rSem, Type type) :
                        {
                          Token t;
                        }
                        {
                           t = <IDENTIFIER> 
                           {
                              System.out.println(t.toString());
                              if (rSem.searchLevel(t.toString()) == null) {
                                Symbol s = new Symbol(t.toString(),rSem.getLevel(),Category.Variable);
                                s.setType(type);
                                rSem.insert(s);

                              }
                              else {
                                //Throw semantic exception
                                printError(t, "Erro Semantico: Variavel '" + t.toString() + "' ja declarada.");
                              }
                           }
                           (<EQUAL> Expression())?
                        }


      /* NAO SEI SE O ENUM EH ASSIM ????????? */
      void EnumDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        <ENUM> 
        {
          type = Type.Enum;
        }
        (EnumVal(rSem, type) | EnumType(rSem, type))
      }

            void EnumVal(SemanticRoutines rSem, Type type) :
            {}
            {
              IdentList(rSem, type)
            }

            void EnumType(SemanticRoutines rSem, Type type) :
            {}
            {
              <TYPE> IdentList(rSem, type) <END> <TYPE>
            }


      void ProcDeclare(SemanticRoutines rSem) : 
      {
        Token t, t2;
        Symbol proc = null;
        java.util.ArrayList<Symbol> par = new java.util.ArrayList<Symbol>();
        int flag = 0;
      }
      {
        (t2 = <PROCEDURE> | t2 = <TYPE> | t2 = <FUNCTION>)
        t = <IDENTIFIER> 
        {
          System.out.println(t.toString());
          if ( rSem.searchLevel(t.toString()) == null ) {
            proc = new Symbol(t.toString(), rSem.getLevel(), Category.Procedure);
            rSem.insert(proc);
            rSem.newLevel();
            flag = 1;
          }
          else {
            //Throw semantic exception
            printError(t, "Erro Semantico: Procedimento '" + t.toString() + "' ja declarado.");
          }
        }

        <LPAREN> 
          ( 
              par = ParamList(rSem) 
              {
                if(proc != null)
                  proc.setParameters(par);
              }
          )? 
          // MUDAR STMBLK ????????????
        <RPAREN> (stmblk(rSem))* 

        <END> ProcedureType(t2)


        {
          if (flag == 1) {

              if(proc!= null) {
                proc.setNPar(par.size());
                
                for (int i = 0; i < par.size(); i++)
                  rSem.insert(par.get(i));
              }
          }
        }

        /*
        {
            proc = rSem.search(t.toString());

            if (proc != null) {
              
              int analisePar = proc.verifyParameters(par);

              if (analisePar == 1 ) {
                printError(t, "Erro semantico: Procedimento '" + t + "' não declarado.");
              } else if (analisePar == 2)
                printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com numero de parametros invalidos.");
              else if (analisePar == 3)
                printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com tipo de parametros invalidos.");
              else {
                //DO SOMETHING
                // está correto
              }

            }
            else {
              printError(t, "Erro semantico: Procedimento '" + t.toString() + "' não declarado.");
            }
        }
        */
      }

            void ProcedureType(Token procType) :
            {
              Token t;
            }
            {
              t = <PROCEDURE> | t = <FUNCTION> | t = <TYPE>
              {
                if(!t.toString().equals(procType.toString()))
                  printError(t, "Erro Sintático: Esperado fechamento de '" + procType.toString());
              }
            }


      java.util.ArrayList<Symbol> ParamList(SemanticRoutines rSem) :
      {
        Symbol s;
        java.util.ArrayList<Symbol> parList = new java.util.ArrayList<Symbol>();
      }
      {
        s = Parameter(rSem) 
        {
          parList.add(s);
        }

        (
            <COMMA> 
            s = Parameter(rSem) 
            {
              parList.add(s);
            }
        )*


        {
          return parList;
        }
      }

            Symbol Parameter(SemanticRoutines rSem) :
            {
              Type type;
              Token t;
            }
            {
              type = DataType() 
              t = <IDENTIFIER>
              {
                if (rSem.searchLevel(t.toString()) == null) {
                  Symbol s = new Symbol(t.toString(), rSem.getLevel(), Category.Parameter);
                  s.setType(type);
                  rSem.insert(s);
                  return s;
                }
                else {
                  printError(t, "Erro Semantico: Parâmetro '" + t.toString() + "' ja declarado.");
                  return null;
                }
              }
            }




void javacc_input() :
{
    Token t;
    SemanticRoutines rSem;
}
{
      {
        rSem = new SemanticRoutines();
      }
    
      ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier())? ( VarDeclare(rSem) | EnumDeclare(rSem) | ProcDeclare(rSem) ) )
      )*
      <EOF>

      {
        if ( errors != 0 ) {
          System.out.println("Análise encontrou " + errors + " erro(s).");
        } 
        else {
          System.out.println("Análises léxica, sintática e semântica concluídas com sucesso!");
        }

      }
}

      void stmblk(SemanticRoutines rSem) :
      {}
      {
          ( statement(rSem) ) | <EOL>
      }

      void statement(SemanticRoutines rSem) :
      {}
      {
            Flow()
          | Loop()
          | Branch()
          | Return()
          | LOOKAHEAD(2) <IDENTIFIER> (Assignment() | Call())
      }

            void Flow() :
            {}
            {
              ( <BREAK> (<INTEGER>)? | <CONTINUE> | <RETRY> | <EXIT> | <FALLTHRU> ) (<STRINGLIT>)?
            }

            void Loop() :
            {}
            {
              ForStatement() | WhileStatement() | LoopStatement() | <GOTO> <LABELSTMT>
            }

                  void ForStatement() :
                  {}
                  {
                    <FOR> //ForIDX() (<LABELSTMT>)? <DO> (stmblk())* <END> <FOR> 
                  }

                        void ForIDX() :
                        {}
                        {
                          <IDENTIFIER> <EQUAL> Expression() <TO> Expression() (<BY> Expression())?
                        }

                  void WhileStatement() :
                  {}
                  {
                    <WHILE> Expression() (<WITHENTRY>)? (<LABELSTMT>)? <DO> //(stmblk())* (EntryStatement())? <END> <WHILE>
                  }

                  void LoopStatement() :
                  {}
                  {
                    <LOOP> (<WITHENTRY>)? (<LABELSTMT>)? <DO> //(stmblk())* (EntryStatement())? <UNTIL> Expression() (<EOL>)* <END> <LOOP>
                  }

                        void EntryStatement() :
                        {}
                        {
                          <ENTRY> //(stmblk())* 
                        }

            void Branch() :
            {}
            {
              IfStatement() | SwitchStatement() | IfDefStatement()
            }

                  void IfStatement() :
                  {}
                  {
                    IfTest() (ElsifStatement())* (ElseStatement())? <END> <IF>
                  }

                        void IfTest() :
                        {}
                        {
                          <IF> Expression() (<LABELSTMT>)? <THEN> //(stmblk())* 
                        }

                        void ElsifStatement() :
                        {}
                        {
                          <ELSIF> Expression() <THEN> //(stmblk())*
                        }

                        void ElseStatement() :
                        {}
                        {
                          <ELSE> //(stmblk())*
                        }


                  void IfDefStatement() :
                  {}
                  {
                    IfDefTest() ( ElsDefIfStatement() <LABELSTMT> )? ( ElsDefStatement())? <ENDDEFIF>
                  }

                        void IfDefTest() :
                        {}
                        {
                          <IFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> //(stmblk())*
                        }

                        void ElsDefIfStatement() :
                        {}
                        {
                          <ELSEIFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> //(stmblk())*
                        }

                        void ElsDefStatement() :
                        {}
                        {
                          <ELSEDEF> //(stmblk())*
                        }

                  void SwitchStatement() :
                  {}
                  {
                    SwitchTest() CaseStatement() (LOOKAHEAD(2) CaseStatement())* //(<CASE> <ELSE> (stmblk())* )? <END> <SWITCH>
                  }

                        void SwitchTest() :
                        {}
                        {
                          <SWITCH> Expression() ((<WITH> | <WITHOUT>) <FALLTHRU>)? (<LABELSTMT>)? <DO> (<EOL>)?
                        }

                        void CaseStatement() :
                        {}
                        {
                          <CASE> CaseList() <THEN> //(stmblk())* 
                        }

                              void CaseList() :
                              {}
                              {
                                Expression() (<COMMA> Expression())* 
                              }


            void Assignment() :
            {}
            {
              AssignmentMulti() | AssignmentWihOp()
            }

                  void AssignmentMulti() :
                  {}
                  {
                    (Variable())? (<COMMA> <IDENTIFIER> (Variable())? )? <EQUAL> Expression() (<COMMA> Expression())?
                  }

                  void AssignmentWihOp() :
                  {}
                  {
                    (<PLUS> | <MINUS> | <SLASH> | <STAR> | <CONCAT> ) <EQUAL> Expression() 
                  }

            void Return() :
            {}
            {
              <RETURN> Expression() (<COMMA> Expression())*
            }

            void Call() :
            {}
            {
              <LPAREN> (ArgList())? <RPAREN>
            }

                  void ArgList() :
                  {}
                  {
                    Expression() ( <COMMA> Expression() )*
                  }


/************************************************************
                        SEQUENCIA
************************************************************/

void Sequence() :
{}
{
  // USE LOOKAHED
  <LBRACE> ( LOOKAHEAD(2) <END_SYMBOL> | Object() (LOOKAHEAD(2) <COMMA> Object())* (<COMMA> <END_SYMBOL>)? )? <RBRACE> 
}


      void Object() :
      {}
      {
        Sequence() | Atom() | <BIN_NUMBER> | <OCT_NUMBER> | <DEC_NUMBER> | <HEX_NUMBER> | <IDENTIFIER> | <STRINGLIT>
      }


/************************************************************
                          EXPRESSÕES
************************************************************/

void Expression() :
{}
{
  Sequence() | Expression00()
}

void Expression00() :
{}
{
  Expression01() ( (<SC_AND> | <SC_OR> | <XOR_OP>) Expression01() )*
}

void Expression01() :
{}
{
  Expression02() ( ( <LT> | <GT> | <LE> | <GE> | <EQUAL> | <NE> ) Expression02() )*
}

void Expression02() :
{}
{
  Expression03() ( <CONCAT> Expression03() )*
}

void Expression03() :
{}
{
  Expression04() ( (<PLUS> | <MINUS>) Expression04() )*
}

void Expression04() :
{}
{
  Expression05() ( (<STAR> | <SLASH>) Expression05() )*
}

void Expression05() :
{}
{
  (<PLUS> | <MINUS> | <NOT_OP>)? Expression06()
}

void Expression06() :
{}
{
  Atom() | <STRINGLIT> | (<LPAREN> Expression() <RPAREN>) | <IDENTIFIER> (Call() | Variable())?
}


      void Variable() :
      {}
      {
        <LBRACKET> Expression() (Slice() | Subscripting())
      }

            void Slice() :
            {}
            {
              <SLICE> ( Expression() | <END_SYMBOL>) <RBRACKET>
            }

            void Subscripting() :
            {}
            {
              <RBRACKET> ( Index() )*
            }

                  void Index() :
                  {}
                  {
                    <LBRACKET> Expression() <RBRACKET>
                  }


/*****************************************
              DATA TYPE
*****************************************/

void ScopeModifier() :
{}
{
  <GLOBAL> | <PUBLIC> | <EXPORT> | <OVERRIDE>
}

Type DataType() :
{
  Token t;
  Type tp;
}
{
  t = <IDENTIFIER>
  {
      System.out.println(t.toString());
      tp = null;
      if(t.toString().equals("atom"))
          tp = Type.Atom;
      else if(t.toString().equals("integer"))
          tp = Type.Int;
      else if(t.toString().equals("sequence"))
          tp = Type.Sequence;
      else if(t.toString().equals("object"))
          tp = Type.Object;
      else if(t.toString().equals("constant"))
          tp = Type.Constant;
      else
        printError(t, "Erro Semantico: Tipo " + t.toString() + " nao existe.");

      return tp;
  }
}

void Real() :
{}
{
  <FLOAT> | <EXP>
}

void Atom() :
{}
{
  <INTEGER> | Real()
}
