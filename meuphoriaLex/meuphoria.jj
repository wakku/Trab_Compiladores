/* **********************************************************************
ANALISADOR LÉXICO
************************************************************************

Integrantes: 
Caio Gomes                  7239072
Diego Gomes                 7656467
Fernando Cury Gorodscy      7152354
Roberty Manzini Bertolo     7573399
Vanessa Apolinário Lima     7239256

Documento:
Codigo fonte

Nome:
MeuPhoria

************************************************************************/


/*****************************************
Opções
*****************************************/
options {
    STATIC = false;
    DEBUG_LOOKAHEAD = false;
    COMMON_TOKEN_ACTION = true ;
}

/*****************************************
Inicialização do Analisador Léxico
*****************************************/
PARSER_BEGIN(Meuphoria)

/* MeuPhoria Parser */
class Meuphoria {

    private static int errors = 0;

// Processa o código e gera a tabela de tokens
    public void processa() throws ParseException, TokenMgrError{
        Token t;
        String nomeToken;
        do {
// Pega o próximo token gerado pelo Léxico.
            t = getNextToken();
            if(t.kind == IDENTIFIER) {
// Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
                if(t.image.length() > 30)
                    throw new TokenMgrError();
            }
// Pega o proximo token do tipo t.kind
            nomeToken = tokenImage[t.kind];
// Seta a localização do token
            String location = "@(" + t.beginLine + ", " + t.beginColumn + ")";
// Imprime as informações do token. Se for EOF não imprime image, pois ela não existe.
            if(t.kind == EOL)
                System.out.println(String.format("%-15s %-20s <EOL>", location, nomeToken));
            else
                System.out.println(String.format("%-15s %-20s %s", location, nomeToken, t.image));
} while (!(nomeToken.equals("<EOF>"))); // Termina o loop se EOF
System.out.println(String.format("%s", t.image));
}

/** Main entry point. */
public static void main(String args[]) {
    try
    {
        java.io.InputStream tmp = System.in;

        java.io.InputStreamReader is = new java.io.InputStreamReader(tmp);
        java.lang.StringBuilder sb=new java.lang.StringBuilder();
        java.io.BufferedReader br = new java.io.BufferedReader(is);
        try {
            String read = br.readLine();

            while(read != null) {
//System.out.println(read);
                sb.append(read + "\n");
                read =br.readLine();

            }
        }
        catch(java.io.IOException e) {
            System.out.println(e.getMessage());
        }

//System.out.println(sb.toString());

// Define o analisador sintatico de acordo com a entrada do sistema
//Meuphoria analisadorSintatico = new Meuphoria(System.in);
        Meuphoria analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

// Roda o loop de processamento enquanto não encontrar EOF
//analisadorlexico.processa();
// Processamento finalizado
//System.out.println("Analisado com sucesso!");

      //analisadorSintatico.javacc_input();
      analisadorSintatico.variables_declaration();

        analisadorSintatico = new Meuphoria(new java.io.StringReader(sb.toString()));

//analisadorSintatico.javacc_input();
//System.out.println("SUCESSO!");
    }
    catch(ParseException e)
    {
        System.out.println(e.getMessage());
        System.out.println("Ocorreu uma excecao!");
    }
    catch(TokenMgrError e)
    {
        System.out.println(e.getMessage());
        System.out.println("Existem erros no codigo! Por favor, verifica-los.");
    }
}
}
PARSER_END(Meuphoria)



TOKEN_MGR_DECLS : { 

//Ação executada para cada Token encontrado
    void CommonTokenAction(Token t) {
        if(t.kind == IDENTIFIER) {
// Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
            if(t.image.length() > 30)
                throw new TokenMgrError();
        }
    }
}



/*****************************************
SKIP
*****************************************/
SKIP : { " " | "\t" | "\r" }

/* Skip Comentários de linha e de bloco */
SKIP :
{
    "/*" : WithinComment
    | <COMENTARIO_INICIAL : "#" (~["\n","\r"])*  >
    | <COMENTARIO_LINHA: "--" (~["\n","\r"])* >
}

<WithinComment> SKIP :
{
    "*/" : DEFAULT
}

<WithinComment> MORE :
{
    <~[]>
}

/*****************************************
TERMINAIS
*****************************************/
TOKEN : {
    < EOL : "\n" >
}

/*****************************************
PALAVRAS RERSERVADAS
*****************************************/
TOKEN : {
    <CASE :	"case">
    | <DO : "do">
    | <END : "end">
    | <EXPORT : "export">
    | <GLOBAL : "global">
    | <INCLUDE : "include">
    | <PUBLIC : "public">
    | <SWITCH : "switch">
    | <UNTIL : "until">
    | <AS : "as">
    | <CONSTANT : "constant">
    | <ELSE : "else">
    | <ENTRY : "entry">
    | <FALLTHRU : "fallthru">
    | <GOTO : "goto">
    | <LABEL : "label">
    | <RETRY : "retry">
    | <THEN : "then">
    | <WHILE : "while">
    | <BREAK : "break">
    | <CONTINUE : "continue">
    | <ELSEDEF : "elsedef">
    | <ENUM : "enum">
    | <IF : "if">
    | <LOOP : "loop">
    | <OVERRIDE : "override">
    | <RETURN : "return">
    | <TO : "to">
    | <WITH : "with">
    | <BY : "by">
    | <DEPRECATE : "deprecate">
    | <ELSIF : "elsif">
    | <EXIT : "exit">
    | <FUNCTION : "function">
    | <IFDEF : "ifdef">
    | <NAMESPACE : "namespace">
    | <PROCEDURE : "procedure">
    | <ROUTINE : "routine">
    | <TYPE : "type">
    | <WITHOUT : "without">
    | <PROFILE : "profile">
    | <PROFILE_TIME : "profile_time">
    | <TRACE : "trace">
    | <BATCH : "batch">
    | <TYPE_CHECK : "type_check">
    | <INDIRECT_INCLUDES : "indirect_includes">
    | <INLINE : "inline">
    | <WARNING : "warning">
    | <SAVE : "save">
    | <RESTORE : "restore">
    | <STRICT : "strict">
    | <ELSEIFDEF : "elsifdef">
    | <FOR : "for">
}

/*****************************************
SEPARADORES
*****************************************/
TOKEN : { 
    <LPAREN: "(" >
        | <RPAREN: ")" >
| <LBRACE: "{" >
| <RBRACE: "}" >
| <LBRACKET: "[" >
| <RBRACKET: "]" >
| <SEMICOLON: ";" >
| <COMMA: "," >
| <DOT: "." >
| <#SINGLE_QUOTE: "\'" >
| <SLICE: ".." >
| <#QUOTE: "\"">
| <#TRIPLE_QUOTE: "\"\"\"">
| <COLON : ":">
}

/*****************************************
OPERADORES
*****************************************/
TOKEN : {
    <NOT_OP: "not" >
    | <PLUS: "+" >
    | <MINUS: "-" >
    | <STAR: "*" >
    | <SLASH: "/" >
    | <ESCLEAD: "\\">
    | <CONCAT: "&" >
    | <GT: ">" >
    | <LT: "<" >
    | <LE: "<=" >
    | <GE: ">=" >
// Depois no sintático, terá que ser adicionado como comando
    | <EQUAL: "=" >
    | <NE: "!=" >
    | <SC_OR: "or" >
    | <SC_AND: "and" >
    | <XOR_OP: "xor" >
| <QMARK : "?"> // print command
| <END_SYMBOL : "$">
}

/*****************************************
VARIAVEIS PRE-DEFINIDAS
*****************************************
TOKEN : {
< ATOM      : "atom" >
| < INT       : "integer" >
| < SEQUENCE  : "sequence" >
| < OBJECT    : "object" >
}

/*****************************************
IDENTIFICADORES
*****************************************/
TOKEN : { 
    < IDENTIFIER : ( ["a"-"z", "A"-"Z"] | "_" ) ( ["a"-"z", "A"-"Z"] | ["0"-"9"] | "_" )* > 
    | < CHAR : (["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
        | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" ) >
}

/*****************************************
MANIPULACAO DE NUMEROS
*****************************************/
TOKEN : {
    < INTEGER : ["0"-"9"] (["0"-"9"] | "_")* >
    | < FLOAT   : <INTEGER> <DOT> ["0"-"9"] (["0"-"9"] | "_")* >
    | < EXP     : (<INTEGER> | <FLOAT>) ("E" | "e") (<PLUS> | <MINUS>)? <INTEGER> >
}


TOKEN : {
    < BIN_NUMBER : "0b" (["0", "1"])+(["0", "1", "_"])* >
    | < OCT_NUMBER : "0t" (["0"-"7"])+(["0"-"7", "_"])* >
    | < DEC_NUMBER : "0d" <INTEGER> >
    | < HEX_NUMBER : "0x" (["0"-"9", "A"-"F"])+(["0"-"9", "A"-"F", "_"])* >
}

/*****************************************
MANIPULAÇÃO DE STRINGS
*****************************************/
TOKEN : {
    < STRINGLIT : <SIMPLESTRINGLIT> | <RAWSTRINGLIT> >
    | < SIMPLESTRINGLIT : <QUOTE>
    (
        ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
        | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
        "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
        "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
        | <BINARY>
        | <HEX2>
        | <HEX4>
        | <HEX8>
        | <ESCCHAR>)* <QUOTE> >
    | < ESCCHAR : <ESCLEAD> ( "n" | "r" | "t" | "\\" | "\"" | "\'" | "0" | "e" | "E" 
        | <BINARY> | <HEX2> | <HEX4> | <HEX8> ) >
| < BINARY : "\\b" (["0", "1"])+(["0", "1", "_"])* >//<BIN> >
| < HEX2 : "\\x" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < HEX4 : "\\u" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < HEX8 : "\\U" ["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"]["0"-"9","A"-"F"] ["0"-"9","A"-"F"] >
| < RAWSTRINGLIT : <DQRAWSTRING> | <BQRAWSTRING> | <VANSTRING> >
| < DQRAWSTRING : "´" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
    | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
    "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
    "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
    | <BINARY>
    | <HEX2>
    | <HEX4>
    | <HEX8>)+
"´" >
| <BQRAWSTRING : "\"\"\"" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " "
    | "." | "!" | "@" | "#" | "$" | "%" | "^" | "*" | "(" | ")" | "-" | "=" | ["0"-"9"] |
    "<" | ">" | "," | ":" | "|" | ";" | "?" | "/" | "~" | "]" | "[" | "{" | "}" | "+" |
    "_" | "`" | "´" | "á" | "é" | "í" | "ó" | "ú" | "ê" | "ã" | "õ"
    | <BINARY>
    | <HEX2>
    | <HEX4>
    | <HEX8>)+
"\"\"\"" >
| <VANSTRING : "\'" 
(
    ["a"-"z", "A"-"Z"] | "_" | "%" | "&" | "$" | "*" | " " | "\\"
    )+
"\'" >
}

/*************************
Statements Básicos
**************************/
TOKEN : {
    < WITHENTRY : <WITH> <ENTRY> >
    | < LABELSTMT : <LABEL> <STRINGLIT> >
}

/*************************
Branching
**************************/

TOKEN : {
    < ENDDEFIF      : <END> <IFDEF> >
}

/*******************************************************
MEUPHORIA GRAMMAR
*******************************************************/

void printError(Token t, String msg):
{
}
{
  {
    errors++;
    System.out.println("[" + t.beginLine + ", " + t.beginColumn + "] " + msg);
  }
}

void variables_declaration() :
{
    SemanticRoutines rSem; 
}
{
    {
        rSem = new SemanticRoutines();
    }

    ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier())? (VarDeclare(rSem) | ProcDeclare(rSem) | EnumDeclare(rSem) /*| FuncDeclare(rSem) */) )
      )*
      <EOF>

      {
        if ( errors != 0 ) {
          System.out.println("Análise encontrou " + errors + " erro(s).");
        } 
        else {
          System.out.println("Análises léxica, sintática e semântica concluídas com sucesso!");
        }
      }
}


void javacc_input() :
{
    Token t;
    SemanticRoutines rSem;
}
{
    {
        rSem = new SemanticRoutines();
      }
    
      ( 
          (LOOKAHEAD(2) stmblk(rSem) | (ScopeModifier(rSem))? (/*ConstantDeclare(rSem) |*/ EnumDeclare(rSem) | ProcDeclare(rSem) /*| FuncDeclare(rSem) */) )
      )*
      <EOF>

      {
        if ( errors != 0 ) {
          System.out.println("Análise encontrou " + errors + " erro(s).");
        } 
        else {
          System.out.println("Análises léxica, sintática e semântica concluídas com sucesso!");
        }

      }
}


      void VarDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        type = DataType(rSem) 

        IdentList(rSem, type)
      }

                  void IdentList(SemanticRoutines rSem, Type type) :
                  {}
                  {
                    Ident(rSem, type) ( <COMMA> Ident(rSem, type) )* 
                  }

                        void Ident(SemanticRoutines rSem, Type type) :
                        {
                          Token t;
                        }
                        {
                           t = <IDENTIFIER> 
                           {
                              System.out.println(t.toString());
                              if (rSem.searchLevel(t.toString()) == null) {
                                Symbol s = new Symbol(t.toString(),rSem.getLevel(),Category.Variable);
                                s.setType(type);
                                rSem.insert(s);

                              }
                              else {
                                //Throw semantic exception
                                printError(t, "Erro Semantico: Variavel '" + t.toString() + "' ja declarada.");
                              }
                           }
                           (<EQUAL> Expression(rSem))?
                        }


      /* NAO SEI SE O ENUM EH ASSIM ????????? */
      void EnumDeclare(SemanticRoutines rSem) :
      {
        Type type;
      }
      {
        <ENUM> 
        {
          type = Type.Enum;
        }
        (EnumVal(rSem, type) | EnumType(rSem, type))
      }

            void EnumVal(SemanticRoutines rSem, Type type) :
            {}
            {
              IdentList(rSem, type)
            }

            void EnumType(SemanticRoutines rSem, Type type) :
            {}
            {
              <TYPE> IdentList(rSem, type) <END> <TYPE>
            }


      void ProcDeclare(SemanticRoutines rSem) : 
      {
        Token t, t2;
        Symbol proc = null;
        java.util.ArrayList<Symbol> par = new java.util.ArrayList<Symbol>();
        int flag = 0;
      }
      {
        (t2 = <PROCEDURE> | t2 = <TYPE> | t2 = <FUNCTION>)
        t = <IDENTIFIER> 
        {
          System.out.println(t.toString());
          if ( rSem.searchLevel(t.toString()) == null ) {
            proc = new Symbol(t.toString(), rSem.getLevel(), Category.Procedure);
            rSem.insert(proc);
            rSem.newLevel();
            flag = 1;
          }
          else {
            //Throw semantic exception
            printError(t, "Erro Semantico: Procedimento '" + t.toString() + "' ja declarado.");
          }
        }

        <LPAREN> 
          ( 
              par = ParamList(rSem) 
              {
                if(proc != null)
                  proc.setParameters(par);
              }
          )? 
          // MUDAR STMBLK ????????????
        <RPAREN> (stmblk(rSem))* 

        <END> ProcedureType(rSem, t2)


        {
          if (flag == 1) {

              if(proc!= null) {
                proc.setNPar(par.size());
                
                for (int i = 0; i < par.size(); i++)
                  rSem.insert(par.get(i));
              }
          }
        }

        /*
        {
            proc = rSem.search(t.toString());

            if (proc != null) {
              
              int analisePar = proc.verifyParameters(par);

              if (analisePar == 1 ) {
                printError(t, "Erro semantico: Procedimento '" + t + "' não declarado.");
              } else if (analisePar == 2)
                printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com numero de parametros invalidos.");
              else if (analisePar == 3)
                printError(t, "Erro semantico: Procedimento '" + t.toString() + "' com tipo de parametros invalidos.");
              else {
                //DO SOMETHING
                // está correto
              }

            }
            else {
              printError(t, "Erro semantico: Procedimento '" + t.toString() + "' não declarado.");
            }
        }
        */
      }

      void ProcedureType(SemanticRoutines rSem, Token procType) :
      {
        Token t;
      }
      {
        t = <PROCEDURE> | t = <FUNCTION> | t = <TYPE>
        {
          if(!t.toString().equals(procType.toString()))
            printError(t, "Erro Sintático: Esperado fechamento de '" + procType.toString());
        }
      }


      java.util.ArrayList<Symbol> ParamList(SemanticRoutines rSem) :
      {
        Symbol s;
        java.util.ArrayList<Symbol> parList = new java.util.ArrayList<Symbol>();
      }
      {
        s = Parameter(rSem) 
        {
          parList.add(s);
        }

        (
            <COMMA> 
            s = Parameter(rSem) 
            {
              parList.add(s);
            }
        )*


        {
          return parList;
        }
      }

            Symbol Parameter(SemanticRoutines rSem) :
            {
              Type type;
              Token t;
            }
            {
              type = DataType(rSem) 
              t = <IDENTIFIER>
              {
                if (rSem.searchLevel(t.toString()) == null) {
                  Symbol s = new Symbol(t.toString(), rSem.getLevel(), Category.Parameter);
                  s.setType(type);
                  rSem.insert(s);
                  return s;
                }
                else {
                  printError(t, "Erro Semantico: Parâmetro '" + t.toString() + "' ja declarado.");
                  return null;
                }
              }
            }






      void stmblk(SemanticRoutines rSem) :
      {}
      {
          ( statement(rSem) ) | <EOL>
      }

      void statement(SemanticRoutines rSem) :
      {}
      {
            Flow(rSem)
          | Loop(rSem)
          | Branch(rSem)
          | Return(rSem)
          | LOOKAHEAD(2) <IDENTIFIER> (Assignment(rSem) | Call(rSem))
          //| (ScopeModifier())? ( VarDeclare(rSem) | TypeDeclare(rSem) )
      }

            void Flow(SemanticRoutines rSem) :
            {}
            {
              ( <BREAK> (<INTEGER>)? | <CONTINUE> | <RETRY> | <EXIT> | <FALLTHRU> ) (<STRINGLIT>)?
            }

void EnumVal(SemanticRoutines rSem, Token type) :
{}
{
    IdentList(rSem, type)
}

void EnumType(SemanticRoutines rSem, Token type) :
{}
{
    <TYPE> IdentList(rSem, type) <END> <TYPE>
}

void ProcDeclare(SemanticRoutines rSem) : 
{}
{
<PROCEDURE> <IDENTIFIER> <LPAREN> (ParamList(rSem))? <RPAREN> //(stmblk())* <END> <PROCEDURE> 
}

void FuncDeclare(SemanticRoutines rSem) :
{}
{
<FUNCTION> <IDENTIFIER> <LPAREN> (ParamList(rSem))? <RPAREN> //(stmblk())* <END> <FUNCTION>
}

            void Call(SemanticRoutines rSem) :
            {}
            {
              <LPAREN> (ArgList(rSem))? <RPAREN>
            }

void ForIDX(SemanticRoutines rSem) :
{}
{
    <IDENTIFIER> <EQUAL> Expression(rSem) <TO> Expression(rSem) (<BY> Expression(rSem))?
}

void WhileStatement(SemanticRoutines rSem) :
{}
{
<WHILE> Expression(rSem) (<WITHENTRY>)? (<LABELSTMT>)? <DO> //(stmblk())* (EntryStatement())? <END> <WHILE>
}

void LoopStatement(SemanticRoutines rSem) :
{}
{
<LOOP> (<WITHENTRY>)? (<LABELSTMT>)? <DO> //(stmblk())* (EntryStatement())? <UNTIL> Expression() (<EOL>)* <END> <LOOP>
}

void EntryStatement(SemanticRoutines rSem) :
{}
{
<ENTRY> //(stmblk())* 
}

void Branch(SemanticRoutines rSem) :
{}
{
    IfStatement(rSem) | SwitchStatement(rSem) | IfDefStatement(rSem)
}

void IfStatement(SemanticRoutines rSem) :
{}
{
    IfTest() (ElsifStatement(rSem))* (ElseStatement(rSem))? <END> <IF>
}

void IfTest(SemanticRoutines rSem) :
{}
{
<IF> Expression(rSem) (<LABELSTMT>)? <THEN> //(stmblk())* 
}

void ElsifStatement(SemanticRoutines rSem) :
{}
{
<ELSIF> Expression(rSem) <THEN> //(stmblk())*
}

void ElseStatement(SemanticRoutines rSem) :
{}
{
<ELSE> //(stmblk())*
}


void IfDefStatement(SemanticRoutines rSem) :
{}
{
    IfDefTest(rSem) ( ElsDefIfStatement(rSem) <LABELSTMT> )? ( ElsDefStatement(rSem))? <ENDDEFIF>
}

void IfDefTest(SemanticRoutines rSem) :
{}
{
<IFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> //(stmblk())*
}

void ElsDefIfStatement(SemanticRoutines rSem) :
{}
{
<ELSEIFDEF> (<NOT_OP>)? <IDENTIFIER> ( (<SC_AND> | <SC_OR>) (<NOT_OP>)? <IDENTIFIER>)? <THEN> //(stmblk())*
}

void ElsDefStatement(SemanticRoutines rSem) :
{}
{
<ELSEDEF> //(stmblk())*
}

void SwitchStatement(SemanticRoutines rSem) :
{}
{
SwitchTest(rSem) CaseStatement(rSem) (LOOKAHEAD(2) CaseStatement(rSem))* //(<CASE> <ELSE> (stmblk())* )? <END> <SWITCH>
}

void SwitchTest(SemanticRoutines rSem) :
{}
{
    <SWITCH> Expression(rSem) ((<WITH> | <WITHOUT>) <FALLTHRU>)? (<LABELSTMT>)? <DO> (<EOL>)?
}

void CaseStatement(SemanticRoutines rSem) :
{}
{
<CASE> CaseList(rSem) <THEN> //(stmblk())* 
}

void CaseList(SemanticRoutines rSem) :
{}
{
    Expression(rSem) (<COMMA> Expression(rSem))* 
}


void Assignment(SemanticRoutines rSem) :
{}
{
    AssignmentMulti(rSem) | AssignmentWihOp(rSem)
}

void AssignmentMulti(SemanticRoutines rSem) :
{}
{
    (Variable(rSem))? (<COMMA> <IDENTIFIER> (Variable(rSem))? )? <EQUAL> Expression(rSem) (<COMMA> Expression(rSem))?
}

void AssignmentWihOp(SemanticRoutines rSem) :
{}
{
    (<PLUS> | <MINUS> | <SLASH> | <STAR> | <CONCAT> ) <EQUAL> Expression(rSem) 
}

void Return(SemanticRoutines rSem) :
{}
{
    <RETURN> Expression(rSem) (<COMMA> Expression(rSem))*
}

void VarDeclare(SemanticRoutines rSem) :
{
    Token type;
}
{
    type = DataType(rSem) 

    IdentList(rSem, type)
}

void IdentList(SemanticRoutines rSem, Token type) :
{}
{
    Ident(rSem, type) ( <COMMA> Ident(rSem, type) )* 
}

void Ident(SemanticRoutines rSem, Token type) :
{
    Token t;
}
{
    t = <IDENTIFIER> 
    {
        System.out.println(t.toString());
        if (rSem.searchLevel(t.toString()) == null) {
            Symbol s = new Symbol(t.toString(),rSem.getLevel(),Category.Variable);
            s.setType(SemanticRoutines.tokenAsType(type));
            rSem.insert(s);

        }
        else {
//Throw semantic exception
            printError(t, "Erro Semantico: Variavel '" + t.toString() + "' ja declarada.");
        }
    }
    (<EQUAL> Expression(rSem))?
}

void TypeDeclare(SemanticRoutines rSem) : 
{
    Token t;
}
{
    <TYPE> 
    t = <IDENTIFIER> 
    <LPAREN> (ParamList(rSem))? <RPAREN> (stmblk(rSem))* <END> <TYPE> 
}

void Call(SemanticRoutines rSem) :
{}
{
    <LPAREN> (ArgList(rSem))? <RPAREN>
}

void ArgList(SemanticRoutines rSem) :
{}
{
    Expression(rSem) ( <COMMA> Expression(rSem) )*
}


/************************************************************
SEQUENCIA
************************************************************/

void Sequence(SemanticRoutines rSem) :
{}
{
// USE LOOKAHED
    <LBRACE> ( LOOKAHEAD(2) <END_SYMBOL> | Object(rSem) (LOOKAHEAD(2) <COMMA> Object(rSem))* (<COMMA> <END_SYMBOL>)? )? <RBRACE> 
}


void Object(SemanticRoutines rSem) :
{}
{
    Sequence(rSem) | Atom(rSem) | <BIN_NUMBER> | <OCT_NUMBER> | <DEC_NUMBER> | <HEX_NUMBER> | <IDENTIFIER> | <STRINGLIT>
}


/************************************************************
EXPRESSÕES
************************************************************/

void Expression(SemanticRoutines rSem) :
{}
{
    Sequence(rSem) | Expression00(rSem)
}

void Expression00(SemanticRoutines rSem) :
{}
{
    Expression01(rSem) ( (<SC_AND> | <SC_OR> | <XOR_OP>) Expression01(rSem) )*
}

void Expression01(SemanticRoutines rSem) :
{}
{
    Expression02(rSem) ( ( <LT> | <GT> | <LE> | <GE> | <EQUAL> | <NE> ) Expression02(rSem) )*
}

void Expression02(SemanticRoutines rSem) :
{}
{
    Expression03(rSem) ( <CONCAT> Expression03(rSem) )*
}

void Expression03(SemanticRoutines rSem) :
{}
{
    Expression04(rSem) ( (<PLUS> | <MINUS>) Expression04(rSem) )*
}

void Expression04(SemanticRoutines rSem) :
{}
{
    Expression05(rSem) ( (<STAR> | <SLASH>) Expression05(rSem) )*
}

void Expression05(SemanticRoutines rSem) :
{}
{
    (<PLUS> | <MINUS> | <NOT_OP>)? Expression06(rSem)
}

void Expression06(SemanticRoutines rSem) :
{}
{
    Atom(rSem) | <STRINGLIT> | (<LPAREN> Expression(rSem) <RPAREN>) | <IDENTIFIER> (Call(rSem) | Variable(rSem))?
}


void Variable(SemanticRoutines rSem) :
{}
{
    <LBRACKET> Expression(rSem) (Slice(rSem) | Subscripting(rSem))
}

void Slice(SemanticRoutines rSem) :
{}
{
    <SLICE> ( Expression(rSem) | <END_SYMBOL>) <RBRACKET>
}

void Subscripting(SemanticRoutines rSem) :
{}
{
    <RBRACKET> ( Index(rSem) )*
}

                  void Index(SemanticRoutines rSem) :
                  {}
                  {
                    <LBRACKET> Expression(rSem) <RBRACKET>
                  }


/*****************************************
DATA TYPE
*****************************************/

void ScopeModifier(SemanticRoutines rSem) :
{}
{
    <GLOBAL> | <PUBLIC> | <EXPORT> | <OVERRIDE>
}

Type DataType(SemanticRoutines rSem) :
{
  Token t;
  Type tp;
}
{
  t = <IDENTIFIER>
  {
      System.out.println(t.toString());
      tp = null;
      if(t.toString().equals("atom"))
          tp = Type.Atom;
      else if(t.toString().equals("integer"))
          tp = Type.Int;
      else if(t.toString().equals("sequence"))
          tp = Type.Sequence;
      else if(t.toString().equals("object"))
          tp = Type.Object;
      else if(t.toString().equals("constant"))
          tp = Type.Constant;
      else
        printError(t, "Erro Semantico: Tipo " + t.toString() + " nao existe.");

      return tp;
  }
}

void Real(SemanticRoutines rSem) :
{}
{
    <FLOAT> | <EXP>
}

void Atom(SemanticRoutines rSem) :
{}
{
    <INTEGER> | Real(rSem)
}
