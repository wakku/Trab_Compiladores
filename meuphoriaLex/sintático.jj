/*

TOKEN : { <ATOM : <ATOM_INTEGER_LIT>|<ATOM_REAL_LIT> > }       // 8 - ATOM

// GAMBI:
TOKEN : { <ATOM_INTEGER_LIT : "something"> }
TOKEN : { <ATOM_REAL_LIT : "something_else"> }
TOKEN : { <INTEGER : "something_other_thing"> }
TOKEN : { <INTEGER_LIT : "another_thing"> }
// END GAMBI

// // IDK HOW TO DO THIS
// TOKEN : { <ATOM_INTEGER_LIT : ["-253"-"+253"] | ["-9.007e15"-"+9.007e15"] > }                    // 9 - ATOM_INTEGER_INT - acho que está certo
// TOKEN : { <ATOM_REAL_LIT : ["-21024+1"-"+21024-1"] | ["-1.798e308+1"-"+1.798e308-1"]> }         // 10 - ATOM_REAL_LIT - acho que está certo
// TOKEN : { <INTEGER : <INTEGER_LIT> > }         // 11
// // IDK HOW TO DO THIS
// TOKEN : { <INTEGER_LIT : ["-230"-"+230-1"] | ["-1_073_741_824"-"+1_073_741_823"]> }         // 12

TOKEN : { <SEQUENCE : "{"<HEADITEM>(<ITEM>)+<LASTITEM> "}"> }      // 13
TOKEN : { <OBJECT : <ATOM>|<INTEGER>|<SEQUENCE> > }        // 14
TOKEN : { <EXPRESSION : <ATOMEXPR> | <INTEXPR> | <STREXPR> | <SEQEXPR> | <BOOLEXPR> > }        // 15
TOKEN : { <ATOMEXPR : <ATOM> > }       // 16
TOKEN : { <INTEXPR : <INTEGER> > }         // 17
TOKEN : { <STREXPR : "an_expression_that_evaluates_to_a_string"> }      // 18 - nÃO SEI SE ESTÁ CERTOOO
TOKEN : { <SEQEXPR : <SEQUENCE> > }        // 19

TOKEN : { <BOOL_LIT : "0" | "1" | "0" | "!0"> }         // 20

TOKEN : { <BOOLEXPR : "atom_zero_represents_falsehood_and_non-zero_represents_truth"> }     // 21 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <RELATIONOP : "<" | ">" | "<=" | ">=" | "=" | "!="> }     // 22 - 
TOKEN : { <BINARYEXPR : (<EXPRESSION> <BINOP> <EXPRESSION>)+ > }  // 23 - 
TOKEN : { <BINOP : "and" | "or" | "xor" | "+" | "-" | "*" | "/" | "&"> }    // 24 - 
TOKEN : { <UNARYEXPR : ( <UNARYOP> <EXPRESSION> )+ > }    // 25 - 
TOKEN : { <UNARYOP : "not" | "-" | "+"> }   // 26 - 
// 27 - RETIRADO DA GRAMATICA
TOKEN : { <HEADITEM : <ATOM>|<INTEGER> > }    // 28 - 
TOKEN : { <ITEM : "," <ATOM>|<INTEGER> > }     // 29 - 
TOKEN : { <LASTITEM : "$"> }    // 30 - 
TOKEN : { <STATEMENT : "complete_unit_of_code_executed_by_the_interpreter"> }   // 31 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <STMBLK : (<STATEMENT>)+ > }  // 32 - 

TOKEN : { <LABEL_EXP : "label"<STRINGLIT>> }     // 33 - 
//TOKEN : { <LISTDELIM : ","> }   // 34 - 
TOKEN : { <STRINGLIT : <SIMPLESTRINGLIT> | <RAWSTRINGLIT>> }    // 35 - 
TOKEN : { <SIMPLESTRINGLIT : <SSLITSTART> ( <CHAR> )+ <SSLITEND>> }  // 36 - 
TOKEN : { <SSLITSTART : "\""> }     // 37 - 
TOKEN : { <SSLITEND : <SSLITSTART>> }   // 38 - 
TOKEN : { <CHAR : "any_byte_value"> }   // 39 - 
TOKEN : { <EESCHAR : <ESCLEAD> ( "t" | "n" | "r" | " " )> }     // 40 - 
TOKEN : { <ESCLEAD : ""> }  // 41 - 

TOKEN : { <RAWSTRINGLIT : <DQRAWSTRING> | <BQRAWSTRING>> }  // 42 - 
TOKEN : { <DQRAWSTRING : "\"\"\"" <MARGINSTR> ( <CHAR> )+ "\"\"\""> }    // 43 - 
TOKEN : { <BQRAWSTRING : "`"  <MARGINSTR> ( <CHAR> )+ "`"> }  // 44 -
TOKEN : { <MARGINSTR : <USCORE>> }   // 45 -  
TOKEN : { <SCOPEMODIFIER : "global" | "public" | "export" | "override"> }   // 46 - 
//TOKEN : { <DATATYPE : "atom" | "integer" | "sequence" | "object" | <IDENTIFIER>> }    // 47 - 
TOKEN : { <INCLUDESTMT : "include" <FILEREF> ( "as" <NAMESPACEID> ) <EOL>> }  // 48 - 
TOKEN : { <FILEREF : "file_path_that_may_be_enclosed_in_double-quotes"> }   // 49 -
TOKEN : { <NAMESPACEID : <IDENTIFIER>> }  // 50 -
TOKEN : { <SLICE : <LBRACKET> <INTEXPR> <SLICEDELIM> ( <INTEXPR> | "$" ) <RBRACKET>> }  // 51 -  
//TOKEN : { <SLICESTART : "["> }  // 52 -  
TOKEN : { <SLICEDELIM : ".."> }     // 53 -  
//TOKEN : { <SLICEEND : "]"> }    // 54 -  
TOKEN : { <IFSTMT : <IF_TEST> ( <ELSIF_TEST> )* ( <ELSE_TEST> )? <ENDIF>> }  // 55 -  
TOKEN : { <IF_TEST : "if" <ATOMEXPR>  (<LABEL_EXP>)? "then" (<STMBLK>)?> }    // 56 -    
TOKEN : { <ELSIF_TEST : "elsif" <ATOMEXPR> "then" (<STMBLK>)?> }    // 57 -  
TOKEN : { <ELSE_TEST : "else" (<STMBLK>)?> }  // 58 -  
TOKEN : { <ENDIF : "end" "if"> }    // 59 -  
TOKEN : { <IFDEFSTMT : <IFDEFTEST> (<ELSDEFIF> (<CHAR>)+)? (<ELSEDEF_TEST>)? <ENDDEFIF>> }  // 60 -  
TOKEN : { <IFDEFTEST : "ifdef" <DEFEXPR> "then" (<STMBLK>)? > }     // 61 -  
TOKEN : { <ELSDEFIF : "elsifedf" <DEFEXPR> "then" (<STMBLK>)? > }   // 62 -    
TOKEN : { <ELSEDEF_TEST : "elsede" (<STMBLK>)? > }  // 63 -  
TOKEN : { <ENDDEFIF : "end" "ifdef"> }  // 64 -  
TOKEN : { <DEFEXPR : <DEFTERM> (<DEFOP> <DEFTERM>)? > }   // 65 -  
TOKEN : { <DEFTERM : ("not" <IDENTIFIER>)? > }    // 66 -  
TOKEN : { <DEFOP : "and" | "or"> }  // 67 -  
TOKEN : { <SWITCHSTMT : <SWITCHTEST> (<CASE_EXP>)+ (<CASEELSE>)? (<ENDSWITCH>)? > }  // 68 -    
TOKEN : { <SWITCHTEST : "switch" <EXPRESSION> (<WITHFALL>)? (<LABEL_EXP>)? "do"> }  // 69 -  
TOKEN : { <WITHFALL : ( "with" | "without" ) "fallthru"> }  // 70 -  
TOKEN : { <CASE_EXP : "case" <CASELIST> "then" (<STMBLK>)?> }  // 71 -  
TOKEN : { <CASELIST : <EXPRESSION> (<COMMA> <EXPRESSION>)+ > }    // 72 -  
TOKEN : { <CASEELSE : "case" "else"> }  // 73 -  
TOKEN : { <ENDSWITCH : "end" "switch"> }    // 74 -    
TOKEN : { <BREAKSTMT : "break" (<STRINGLIT>)?> }     // 75 -  
TOKEN : { <CONTINUESTMT : "continue" (<STRINGLIT>)? > }   // 76 -  
TOKEN : { <RETRYSTMT : "retry" (<STRINGLIT>)? > }     // 77 -  
TOKEN : { <EXITSTMT : "exit" (<STRINGLIT>)? > }   // 78 -  

//TOKEN : { <FALLTHRUSTMT : "fallthru"> }     // 79 -  
TOKEN : { <FORSTMT : "for" <FORIDX> (<LABEL_EXP>)? "do" (<STMBLK>)? "end" "for"> }  // 80 -    
TOKEN : { <FORIDX : <IDENTIFIER> "=" <ATOMEXPR> "to" <ATOMEXPR> ("by"<ATOMEXPR>)? > }  // 81 -  
TOKEN : { <WHILESTMT : "while" <BOOLEXPR> (<WITHENTRY>)? (<LABEL_EXP>)? "do" <STMBLK> (<ENTRY_EXP>)? "end" "while"> }  // 82 -  
TOKEN : { <WITHENTRY : "with" "entry"> }    // 83 -  
TOKEN : { <ENTRY_EXP : "entry" (<STMBLK>)?> }    // 84 -  
TOKEN : { <LOOPSTMT : "loop" (<WITHENTRY>)? (<LABEL_EXP>)? "do" <STMBLK> (<ENTRY_EXP>)? "until" <BOOLEXPR> "end" "loop"> }   // 85 -  
TOKEN : { <GOTOSTMT : "goto" <LABEL_EXP>> }   // 86 -
TOKEN : { <VARDECLARE : (<SCOPEMODIFIER>)? <DATATYPE> <IDENTLIST>> }     // 87 -        
TOKEN : { <IDENTLIST : <IDENT> ("," <IDENT>)+> }   // 88 -        
TOKEN : { <IDENT : <IDENTIFIER> ("=" <EXPRESSION>)?> }     // 89 -
TOKEN : { <CONSTDECLARE : (<SCOPEMODIFIER>)? "constant" <IDENTLIST>> }     // 90 -                
TOKEN : { <ENUMDECLARE : (<SCOPEMODIFIER>)? (<ENUMVAL> | <ENUMTYPE>)?> }    // 91 -                
TOKEN : { <ENUMVAL : "enum" ("by" <ENUMDELTA>)? <IDENTLIST>> }     // 92 -                
TOKEN : { <ENUMDELTA : ("+" | "-" | "*" | "/")? <ATOMEXPR>> }    // 93 -                
TOKEN : { <ENUMTYPE : "enum" "type" ("by" <ENUMDELTA>)? <IDENTLIST> "end" "type"> }    // 94 -                
TOKEN : { <CALL : <IDENTIFIER> "(" (<ARGLIST>)? ")"> }     // 95 -                
TOKEN : { <ARGLIST : <ARGUMENT> ("," <ARGUMENT>)+> }    // 96 -                
TOKEN : { <ARGUMENT : <EXPRESSION>> }     // 97 -                
TOKEN : { <PROCDECLARE : (<SCOPEMODIFIER>)? "procedure" <IDENTIFIER> "(" (<PARAMLIST>)? ")" (<STMBLK>)? "end" "procedure"> }     // 98 -                
TOKEN : { <PARAMLIST : <PARAMETER> ("," <PARAMETER>)+> }   // 99 -
TOKEN : { <PARAMETER : <DATATYPE> <IDENTIFIER>> }   // 100 -
TOKEN : { <FUNCDECLARE : (<SCOPEMODIFIER>)? "function" <IDENTIFIER> "(" (<PARAMLIST>)? ")" (<STMBLK>)? "end" "function"> }   // 101 -
TOKEN : { <TYPEDECLAR : (<SCOPEMODIFIER>)? "type" <IDENTIFIER> "(" <PARAMETER> ")" (<STMBLK>)? "end" "type"> }    // 102 -
TOKEN : { <RETURN_EXP : "return" <EXPRESSION>> }  // 103 -
TOKEN : { <NAMESPACE_EXP : "namespace" <IDENTIFIER> <EOL>> }    // 104 -
TOKEN : { <WITHSTMT : ("with" | "without")? <WITHOPTION>> }  // 105 -
TOKEN : { <WITHOPTION : ("profile" | "profile_time" | "trace" | "batch" | "type_check" | "indirect_includes" | "inline" | <WITHWARNING>)? > }     // 106 -
TOKEN : { <WITHWARNING : "warning" (<WARNOPT>)?> }   // 107 -
TOKEN : { <WARNOPT : <SETWARN> | (<ADDWARN>)? | <SAVEWARN> | <RESTOREWARN> | <STRICTWARN>> }    // 108 - addwarn não foi criado?
TOKEN : { <SETWARN : ("+=" | "&=")? "{" (<WARNLIST>)? "}"> }   // 109 - warnlist não foi criado em nenhum lugar :/
TOKEN : { <WARNLIST : "warnlist"> }// Pensei em criar assim, pelo que entendi é a lista impressa dos erros, não acho que vamos fazer algo no lexico
TOKEN : { <ADDWARN : "add"> }// Pensei em criar assim
TOKEN : { <SAVEWARN : "save"> }     // 110 -
TOKEN : { <RESTOREWARN : "restore"> }   // 111 -
TOKEN : { <STRICTWARN : "strict"> }     // 112 -
TOKEN : { <SUBSCRIPTING : <IDENTIFIER> (<INDEX>)+ > }   // 113 -
TOKEN : { <INDEX : "[" <INTEXPR> "]"> }   // 114 -
TOKEN : { <ASSIGNMONO : <IDENTIFIER> "=" <EXPRESSION>> }    // 115 -
TOKEN : { <ASSIGNMULTI : "{" <IDENTIFIER> ( "," <IDENTIFIER>)* "}" "=" <EXPRESSION> | "{" <EXPRESSION> ( "," <EXPRESSION> )* "}"> }    // 116 -
TOKEN : { <ASSIGNWITHOP : <IDENTIFIER> ( "+" | "-" | "/" | "*" | "&" )? "=" <EXPRESSION>> }  // 117 -

*/