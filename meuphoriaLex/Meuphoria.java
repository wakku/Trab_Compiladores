/* Meuphoria.java */
/* Generated By:JavaCC: Do not edit this line. Meuphoria.java */
/* MeuPhoria Parser */
class Meuphoria implements MeuphoriaConstants {

  // Processa o código e gera a tabela de tokens
  public void processa() throws ParseException, TokenMgrError{
    Token t;
    String nomeToken;
    do {
        // Pega o próximo token gerado pelo Léxico.
        t = getNextToken();
        if(t.kind == IDENTIFIER) {
        // Se tamanho for maior que 30, váriavel é invalida. Gera um erro.
                if(t.image.length() > 30)
                throw new TokenMgrError();
        }
        // Pega o proximo token do tipo t.kind
        nomeToken = tokenImage[t.kind];
        // Seta a localização do token
        String location = "@(" + t.beginLine + ", " + t.beginColumn + ")";
        // Imprime as informações do token. Se for EOF não imprime image, pois ela não existe.
        if(t.kind == EOL)
                        System.out.println(String.format("%-15s %-20s <EOL>", location, nomeToken));
        else
                        System.out.println(String.format("%-15s %-20s %s", location, nomeToken, t.image));
    } while (!(nomeToken.equals("<EOF>"))); // Termina o loop se EOF
    System.out.println(String.format("%s", t.image));
  }

  /** Main entry point. */
  public static void main(String args[]) {
    try
    {
      // Define o analisador lexico de acordo com a entrada do sistema
      Meuphoria analisadorlexico = new Meuphoria(System.in);
      // Roda o loop de processamento enquanto não encontrar EOF
      //analisadorlexico.processa();
      // Processamento finalizado
      //System.out.println("Analisado com sucesso!");

      analisadorlexico.javacc_input();
      System.out.println("input... ");
    }
    catch(ParseException e)
    {
      System.out.println(e.getMessage());
        System.out.println("Ocorreu uma excecao!");
    }
    catch(TokenMgrError e)
    {
        System.out.println(e.getMessage());
        System.out.println("Existem erros no codigo! Por favor, verifica-los.");
    }
  }

/*************************
        Atribuição
**************************
TOKEN : {
    < ASSIGNMONO    : <IDENTIFIER> <EQUAL> <EXPRESSION> >
  | < ASSIGNMULTI   : <IDENTIFIER> (<COMMA> <IDENTIFIER>)? <EQUAL> <EXPRESSION> (<COMMA> <EXPRESSION>)? >
  | < ASSIGNWITHOP  : <IDENTIFIER> (<PLUS> | <MINUS> | <SLASH> | <STAR> | <CONCAT> ) <EQUAL> <EXPRESSION> >
}

/*************************
          Return
**************************
TOKEN : {
  < RETURNSTMT : <RETURN> <EXPRESSION> (<COMMA> <EXPRESSION>)* >
}

/*************************
  Declaração de Variáveis
**************************
TOKEN : {
  < VARDECLARE : (<SCOPEMODIFIER>)? <DATATYPE> <IDENTLIST> >
}

/*************************
  Delaração de Constantes
**************************
TOKEN : {
  < CONSTDECLARE : (<SCOPEMODIFIER>)? <CONSTANT> <IDENTLIST> >
}

/*************************
 Declaração de Enumeração
**************************
TOKEN : {
    < ENUMDELTA : (<PLUS> | <MINUS> | <STAR> | <SLASH>)? <EXPRESSION> >
  | < ENUMVAL   : <ENUM> (<BY> <ENUMDELTA>)? <IDENTLIST> >
  | < ENUMTYPE  : <ENUM> <TYPE> (<BY> <ENUMDELTA>)? <IDENTLIST> <END> <TYPE> >
}

/*************************
  Declaração de Processos
**************************
TOKEN : {
  < PROCDECLARE :  (<SCOPEMODIFIER>)? <PROCEDURE> <IDENTIFIER> <LPAREN> (<PARAMLIST>)? <RPAREN> (<STMBLK>)? <END> <PROCEDURE> >
}

/*************************
  Declaração de Função
**************************
TOKEN : {
  < FUNCDECLARE :  (<SCOPEMODIFIER>)? <FUNCTION> <IDENTIFIER> <LPAREN> (<PARAMLIST>)? <RPAREN> (<STMBLK>)? <END> <FUNCTION> >
}

/*************************
    Declaração de Tipo
**************************
TOKEN : {
  < TYPEDECLARE :  (<SCOPEMODIFIER>)? <TYPE> <IDENTIFIER> <LPAREN> (<PARAMLIST>)? <RPAREN> (<STMBLK>)? <END> <TYPE> >
}

/*******************************************************
                MEUPHORIA GRAMMAR
*******************************************************/
  final public 
void javacc_input() throws ParseException {
    trace_call("javacc_input");
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case CONSTANT:
        case GOTO:
        case WHILE:
        case ENUM:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case FUNCTION:
        case IFDEF:
        case PROCEDURE:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        if (jj_2_1(2)) {
          stmblk();
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EXPORT:
          case GLOBAL:
          case PUBLIC:
          case CONSTANT:
          case ENUM:
          case OVERRIDE:
          case FUNCTION:
          case PROCEDURE:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case EXPORT:
            case GLOBAL:
            case PUBLIC:
            case OVERRIDE:{
              ScopeModifier();
              break;
              }
            default:
              jj_la1[1] = jj_gen;
              ;
            }
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case CONSTANT:{
              ConstantDeclare();
              break;
              }
            case ENUM:{
              EnumDeclare();
              break;
              }
            case PROCEDURE:{
              ProcDeclare();
              break;
              }
            case FUNCTION:{
              FuncDeclare();
              break;
              }
            default:
              jj_la1[2] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[3] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(0);
    } finally {
      trace_return("javacc_input");
    }
  }

  final public void ConstantDeclare() throws ParseException {
    trace_call("ConstantDeclare");
    try {
      jj_consume_token(CONSTANT);
      IdentList();
    } finally {
      trace_return("ConstantDeclare");
    }
  }

  final public void EnumDeclare() throws ParseException {
    trace_call("EnumDeclare");
    try {
      jj_consume_token(ENUM);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFIER:{
        EnumVal();
        break;
        }
      case TYPE:{
        EnumType();
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("EnumDeclare");
    }
  }

  final public void EnumVal() throws ParseException {
    trace_call("EnumVal");
    try {
      IdentList();
    } finally {
      trace_return("EnumVal");
    }
  }

  final public void EnumType() throws ParseException {
    trace_call("EnumType");
    try {
      jj_consume_token(TYPE);
      IdentList();
      jj_consume_token(END);
      jj_consume_token(TYPE);
    } finally {
      trace_return("EnumType");
    }
  }

//void EnumDelta() :
                  //{}
                  //{
                  //  <BY> /*(<PLUS> | <MINUS> |*/( <STAR> | <SLASH>)? Expression()  // !!!!!!!!!!!!!!!!            
                  //}
  final public 
      void ProcDeclare() throws ParseException {
    trace_call("ProcDeclare");
    try {
      jj_consume_token(PROCEDURE);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:{
        ParamList();
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[6] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(PROCEDURE);
    } finally {
      trace_return("ProcDeclare");
    }
  }

  final public void FuncDeclare() throws ParseException {
    trace_call("FuncDeclare");
    try {
      jj_consume_token(FUNCTION);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:{
        ParamList();
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(FUNCTION);
    } finally {
      trace_return("FuncDeclare");
    }
  }

  final public void stmblk() throws ParseException {
    trace_call("stmblk");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        statement();
        break;
        }
      case EOL:{
        jj_consume_token(EOL);
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("stmblk");
    }
  }

  final public void statement() throws ParseException {
    trace_call("statement");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        Flow();
        break;
        }
      case GOTO:
      case WHILE:
      case LOOP:
      case FOR:{
        Loop();
        break;
        }
      case SWITCH:
      case IF:
      case IFDEF:{
        Branch();
        break;
        }
      case RETURN:{
        Return();
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        if (jj_2_2(2)) {
          jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACKET:
          case COMMA:
          case PLUS:
          case MINUS:
          case STAR:
          case SLASH:
          case CONCAT:
          case EQUAL:{
            Assignment();
            break;
            }
          case LPAREN:{
            Call();
            break;
            }
          default:
            jj_la1[10] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EXPORT:
          case GLOBAL:
          case PUBLIC:
          case OVERRIDE:
          case TYPE:
          case ATOM:
          case INT:
          case SEQUENCE:
          case OBJECT:
          case IDENTIFIER:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case EXPORT:
            case GLOBAL:
            case PUBLIC:
            case OVERRIDE:{
              ScopeModifier();
              break;
              }
            default:
              jj_la1[11] = jj_gen;
              ;
            }
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case ATOM:
            case INT:
            case SEQUENCE:
            case OBJECT:
            case IDENTIFIER:{
              VarDeclare();
              break;
              }
            case TYPE:{
              TypeDeclare();
              break;
              }
            default:
              jj_la1[12] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } finally {
      trace_return("statement");
    }
  }

  final public void Flow() throws ParseException {
    trace_call("Flow");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BREAKSTMT:{
        jj_consume_token(BREAKSTMT);
        break;
        }
      case CONTINUESTMT:{
        jj_consume_token(CONTINUESTMT);
        break;
        }
      case RETRYSTMT:{
        jj_consume_token(RETRYSTMT);
        break;
        }
      case EXITSTMT:{
        jj_consume_token(EXITSTMT);
        break;
        }
      case FALLTHRUSTMT:{
        jj_consume_token(FALLTHRUSTMT);
        break;
        }
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Flow");
    }
  }

  final public void Loop() throws ParseException {
    trace_call("Loop");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FOR:{
        ForStatement();
        break;
        }
      case WHILE:{
        WhileStatement();
        break;
        }
      case LOOP:{
        LoopStatement();
        break;
        }
      case GOTO:{
        jj_consume_token(GOTO);
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Loop");
    }
  }

  final public void ForStatement() throws ParseException {
    trace_call("ForStatement");
    try {
      jj_consume_token(FOR);
      ForIDX();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LABELSTMT:{
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      jj_consume_token(DO);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(FOR);
    } finally {
      trace_return("ForStatement");
    }
  }

  final public void ForIDX() throws ParseException {
    trace_call("ForIDX");
    try {
      jj_consume_token(IDENTIFIER);
      jj_consume_token(EQUAL);
      Expression();
      jj_consume_token(TO);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case BY:{
        jj_consume_token(BY);
        Expression();
        break;
        }
      default:
        jj_la1[19] = jj_gen;
        ;
      }
    } finally {
      trace_return("ForIDX");
    }
  }

  final public void WhileStatement() throws ParseException {
    trace_call("WhileStatement");
    try {
      jj_consume_token(WHILE);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHENTRY:{
        jj_consume_token(WITHENTRY);
        break;
        }
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LABELSTMT:{
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jj_consume_token(DO);
      stmblk();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTRY:{
        EntryStatement();
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(WHILE);
    } finally {
      trace_return("WhileStatement");
    }
  }

  final public void LoopStatement() throws ParseException {
    trace_call("LoopStatement");
    try {
      jj_consume_token(LOOP);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITHENTRY:{
        jj_consume_token(WITHENTRY);
        break;
        }
      default:
        jj_la1[23] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LABELSTMT:{
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      jj_consume_token(DO);
      stmblk();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ENTRY:{
        EntryStatement();
        break;
        }
      default:
        jj_la1[25] = jj_gen;
        ;
      }
      jj_consume_token(UNTIL);
      Expression();
      jj_consume_token(END);
      jj_consume_token(LOOP);
    } finally {
      trace_return("LoopStatement");
    }
  }

  final public void EntryStatement() throws ParseException {
    trace_call("EntryStatement");
    try {
      jj_consume_token(ENTRY);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[26] = jj_gen;
        ;
      }
    } finally {
      trace_return("EntryStatement");
    }
  }

  final public void Branch() throws ParseException {
    trace_call("Branch");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IF:{
        IfStatement();
        break;
        }
      case SWITCH:{
        SwitchStatement();
        break;
        }
      case IFDEF:{
        IfDefStatement();
        break;
        }
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Branch");
    }
  }

  final public void IfStatement() throws ParseException {
    trace_call("IfStatement");
    try {
      IfTest();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case ELSIF:{
          ;
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          break label_2;
        }
        ElsifStatement();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        ElseStatement();
        break;
        }
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(IF);
    } finally {
      trace_return("IfStatement");
    }
  }

  final public void IfTest() throws ParseException {
    trace_call("IfTest");
    try {
      jj_consume_token(IF);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LABELSTMT:{
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(THEN);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case GOTO:
        case WHILE:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case IFDEF:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          break label_3;
        }
        stmblk();
      }
    } finally {
      trace_return("IfTest");
    }
  }

  final public void ElsifStatement() throws ParseException {
    trace_call("ElsifStatement");
    try {
      jj_consume_token(ELSIF);
      Expression();
      jj_consume_token(THEN);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case GOTO:
        case WHILE:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case IFDEF:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[32] = jj_gen;
          break label_4;
        }
        stmblk();
      }
    } finally {
      trace_return("ElsifStatement");
    }
  }

  final public void ElseStatement() throws ParseException {
    trace_call("ElseStatement");
    try {
      jj_consume_token(ELSE);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case GOTO:
        case WHILE:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case IFDEF:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[33] = jj_gen;
          break label_5;
        }
        stmblk();
      }
    } finally {
      trace_return("ElseStatement");
    }
  }

  final public void IfDefStatement() throws ParseException {
    trace_call("IfDefStatement");
    try {
      IfDefTest();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSEIFDEF:{
        ElsDefIfStatement();
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSEDEF:{
        ElsDefStatement();
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(ENDDEFIF);
    } finally {
      trace_return("IfDefStatement");
    }
  }

  final public void IfDefTest() throws ParseException {
    trace_call("IfDefTest");
    try {
      jj_consume_token(IFDEF);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT_OP:{
        jj_consume_token(NOT_OP);
        break;
        }
      default:
        jj_la1[36] = jj_gen;
        ;
      }
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_OR:
      case SC_AND:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SC_AND:{
          jj_consume_token(SC_AND);
          break;
          }
        case SC_OR:{
          jj_consume_token(SC_OR);
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NOT_OP:{
          jj_consume_token(NOT_OP);
          break;
          }
        default:
          jj_la1[38] = jj_gen;
          ;
        }
        jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[39] = jj_gen;
        ;
      }
      jj_consume_token(THEN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[40] = jj_gen;
        ;
      }
    } finally {
      trace_return("IfDefTest");
    }
  }

  final public void ElsDefIfStatement() throws ParseException {
    trace_call("ElsDefIfStatement");
    try {
      jj_consume_token(ELSEIFDEF);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT_OP:{
        jj_consume_token(NOT_OP);
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        ;
      }
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SC_OR:
      case SC_AND:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SC_AND:{
          jj_consume_token(SC_AND);
          break;
          }
        case SC_OR:{
          jj_consume_token(SC_OR);
          break;
          }
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case NOT_OP:{
          jj_consume_token(NOT_OP);
          break;
          }
        default:
          jj_la1[43] = jj_gen;
          ;
        }
        jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      jj_consume_token(THEN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        ;
      }
    } finally {
      trace_return("ElsDefIfStatement");
    }
  }

  final public void ElsDefStatement() throws ParseException {
    trace_call("ElsDefStatement");
    try {
      jj_consume_token(ELSEDEF);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case GOTO:
        case WHILE:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case IFDEF:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[46] = jj_gen;
          break label_6;
        }
        stmblk();
      }
    } finally {
      trace_return("ElsDefStatement");
    }
  }

  final public void SwitchStatement() throws ParseException {
    trace_call("SwitchStatement");
    try {
      SwitchTest();
      CaseStatement();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CASE:{
          ;
          break;
          }
        default:
          jj_la1[47] = jj_gen;
          break label_7;
        }
        CaseStatement();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ELSE:{
        jj_consume_token(ELSE);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case EOL:
          case EXPORT:
          case GLOBAL:
          case PUBLIC:
          case SWITCH:
          case GOTO:
          case WHILE:
          case IF:
          case LOOP:
          case OVERRIDE:
          case RETURN:
          case IFDEF:
          case TYPE:
          case FOR:
          case ATOM:
          case INT:
          case SEQUENCE:
          case OBJECT:
          case IDENTIFIER:
          case BREAKSTMT:
          case CONTINUESTMT:
          case RETRYSTMT:
          case EXITSTMT:
          case FALLTHRUSTMT:{
            ;
            break;
            }
          default:
            jj_la1[48] = jj_gen;
            break label_8;
          }
          stmblk();
        }
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(SWITCH);
    } finally {
      trace_return("SwitchStatement");
    }
  }

  final public void SwitchTest() throws ParseException {
    trace_call("SwitchTest");
    try {
      jj_consume_token(SWITCH);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case WITH:
      case WITHOUT:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case WITH:{
          jj_consume_token(WITH);
          break;
          }
        case WITHOUT:{
          jj_consume_token(WITHOUT);
          break;
          }
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(FALLTHRU);
        break;
        }
      default:
        jj_la1[51] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LABELSTMT:{
        jj_consume_token(LABELSTMT);
        break;
        }
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      jj_consume_token(DO);
    } finally {
      trace_return("SwitchTest");
    }
  }

  final public void CaseStatement() throws ParseException {
    trace_call("CaseStatement");
    try {
      jj_consume_token(CASE);
      CaseList();
      jj_consume_token(THEN);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case EOL:
        case EXPORT:
        case GLOBAL:
        case PUBLIC:
        case SWITCH:
        case GOTO:
        case WHILE:
        case IF:
        case LOOP:
        case OVERRIDE:
        case RETURN:
        case IFDEF:
        case TYPE:
        case FOR:
        case ATOM:
        case INT:
        case SEQUENCE:
        case OBJECT:
        case IDENTIFIER:
        case BREAKSTMT:
        case CONTINUESTMT:
        case RETRYSTMT:
        case EXITSTMT:
        case FALLTHRUSTMT:{
          ;
          break;
          }
        default:
          jj_la1[53] = jj_gen;
          break label_9;
        }
        stmblk();
      }
    } finally {
      trace_return("CaseStatement");
    }
  }

  final public void CaseList() throws ParseException {
    trace_call("CaseList");
    try {
      Expression();
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[54] = jj_gen;
          break label_10;
        }
        jj_consume_token(COMMA);
        Expression();
      }
    } finally {
      trace_return("CaseList");
    }
  }

  final public void Assignment() throws ParseException {
    trace_call("Assignment");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:
      case COMMA:
      case EQUAL:{
        AssignmentMulti();
        break;
        }
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case CONCAT:{
        AssignmentWihOp();
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Assignment");
    }
  }

/*void AssignmentMono() :
                  {}
                  {
                    <EQUAL> Expression() 
                  }*/
  final public 
                  void AssignmentMulti() throws ParseException {
    trace_call("AssignmentMulti");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACKET:{
        Variable();
        break;
        }
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:{
          Variable();
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      jj_consume_token(EQUAL);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMMA:{
        jj_consume_token(COMMA);
        Expression();
        break;
        }
      default:
        jj_la1[59] = jj_gen;
        ;
      }
    } finally {
      trace_return("AssignmentMulti");
    }
  }

  final public void AssignmentWihOp() throws ParseException {
    trace_call("AssignmentWihOp");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PLUS:{
        jj_consume_token(PLUS);
        break;
        }
      case MINUS:{
        jj_consume_token(MINUS);
        break;
        }
      case SLASH:{
        jj_consume_token(SLASH);
        break;
        }
      case STAR:{
        jj_consume_token(STAR);
        break;
        }
      case CONCAT:{
        jj_consume_token(CONCAT);
        break;
        }
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(EQUAL);
      Expression();
    } finally {
      trace_return("AssignmentWihOp");
    }
  }

  final public void Return() throws ParseException {
    trace_call("Return");
    try {
      jj_consume_token(RETURN);
      Expression();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[61] = jj_gen;
          break label_11;
        }
        jj_consume_token(COMMA);
        Expression();
      }
    } finally {
      trace_return("Return");
    }
  }

  final public void VarDeclare() throws ParseException {
    trace_call("VarDeclare");
    try {
      DataType();
      IdentList();
    } finally {
      trace_return("VarDeclare");
    }
  }

  final public void IdentList() throws ParseException {
    trace_call("IdentList");
    try {
      Ident();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[62] = jj_gen;
          break label_12;
        }
        jj_consume_token(COMMA);
        Ident();
      }
    } finally {
      trace_return("IdentList");
    }
  }

  final public void Ident() throws ParseException {
    trace_call("Ident");
    try {
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EQUAL:{
        jj_consume_token(EQUAL);
        Expression();
        break;
        }
      default:
        jj_la1[63] = jj_gen;
        ;
      }
    } finally {
      trace_return("Ident");
    }
  }

  final public void TypeDeclare() throws ParseException {
    trace_call("TypeDeclare");
    try {
      jj_consume_token(TYPE);
      jj_consume_token(IDENTIFIER);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:{
        ParamList();
        break;
        }
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:
      case EXPORT:
      case GLOBAL:
      case PUBLIC:
      case SWITCH:
      case GOTO:
      case WHILE:
      case IF:
      case LOOP:
      case OVERRIDE:
      case RETURN:
      case IFDEF:
      case TYPE:
      case FOR:
      case ATOM:
      case INT:
      case SEQUENCE:
      case OBJECT:
      case IDENTIFIER:
      case BREAKSTMT:
      case CONTINUESTMT:
      case RETRYSTMT:
      case EXITSTMT:
      case FALLTHRUSTMT:{
        stmblk();
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      jj_consume_token(END);
      jj_consume_token(TYPE);
    } finally {
      trace_return("TypeDeclare");
    }
  }

  final public void Call() throws ParseException {
    trace_call("Call");
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:
      case LBRACE:
      case NOT_OP:
      case PLUS:
      case MINUS:
      case IDENTIFIER:
      case INTEGER:
      case FLOAT:
      case EXP:
      case STRINGLIT:{
        ArgList();
        break;
        }
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
    } finally {
      trace_return("Call");
    }
  }

  final public void ArgList() throws ParseException {
    trace_call("ArgList");
    try {
      Expression();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[67] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        Expression();
      }
    } finally {
      trace_return("ArgList");
    }
  }

/************************************************************
                        SEQUENCIA
************************************************************/
  final public 
void Sequence() throws ParseException {
    trace_call("Sequence");
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:
      case END_SYMBOL:
      case IDENTIFIER:
      case INTEGER:
      case FLOAT:
      case EXP:
      case BIN_NUMBER:
      case OCT_NUMBER:
      case DEC_NUMBER:
      case HEX_NUMBER:
      case STRINGLIT:{
        if (jj_2_4(2)) {
          jj_consume_token(END_SYMBOL);
        } else {
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LBRACE:
          case IDENTIFIER:
          case INTEGER:
          case FLOAT:
          case EXP:
          case BIN_NUMBER:
          case OCT_NUMBER:
          case DEC_NUMBER:
          case HEX_NUMBER:
          case STRINGLIT:{
            Object();
            label_14:
            while (true) {
              if (jj_2_3(2)) {
                ;
              } else {
                break label_14;
              }
              jj_consume_token(COMMA);
              Object();
            }
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case COMMA:{
              jj_consume_token(COMMA);
              jj_consume_token(END_SYMBOL);
              break;
              }
            default:
              jj_la1[68] = jj_gen;
              ;
            }
            break;
            }
          default:
            jj_la1[69] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        ;
      }
      jj_consume_token(RBRACE);
    } finally {
      trace_return("Sequence");
    }
  }

  final public void Object() throws ParseException {
    trace_call("Object");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
        Sequence();
        break;
        }
      case INTEGER:
      case FLOAT:
      case EXP:{
        Atom();
        break;
        }
      case BIN_NUMBER:{
        jj_consume_token(BIN_NUMBER);
        break;
        }
      case OCT_NUMBER:{
        jj_consume_token(OCT_NUMBER);
        break;
        }
      case DEC_NUMBER:{
        jj_consume_token(DEC_NUMBER);
        break;
        }
      case HEX_NUMBER:{
        jj_consume_token(HEX_NUMBER);
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      case STRINGLIT:{
        jj_consume_token(STRINGLIT);
        break;
        }
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Object");
    }
  }

/************************************************************
                          EXPRESSÕES
************************************************************/
  final public 
void Expression() throws ParseException {
    trace_call("Expression");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LBRACE:{
        Sequence();
        break;
        }
      case LPAREN:
      case NOT_OP:
      case PLUS:
      case MINUS:
      case IDENTIFIER:
      case INTEGER:
      case FLOAT:
      case EXP:
      case STRINGLIT:{
        Expression00();
        break;
        }
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Expression");
    }
  }

  final public void Expression00() throws ParseException {
    trace_call("Expression00");
    try {
      Expression01();
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SC_OR:
        case SC_AND:
        case XOR_OP:{
          ;
          break;
          }
        default:
          jj_la1[73] = jj_gen;
          break label_15;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case SC_AND:{
          jj_consume_token(SC_AND);
          break;
          }
        case SC_OR:{
          jj_consume_token(SC_OR);
          break;
          }
        case XOR_OP:{
          jj_consume_token(XOR_OP);
          break;
          }
        default:
          jj_la1[74] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression01();
      }
    } finally {
      trace_return("Expression00");
    }
  }

  final public void Expression01() throws ParseException {
    trace_call("Expression01");
    try {
      Expression02();
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case GT:
        case LT:
        case LE:
        case GE:
        case EQUAL:
        case NE:{
          ;
          break;
          }
        default:
          jj_la1[75] = jj_gen;
          break label_16;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LT:{
          jj_consume_token(LT);
          break;
          }
        case GT:{
          jj_consume_token(GT);
          break;
          }
        case LE:{
          jj_consume_token(LE);
          break;
          }
        case GE:{
          jj_consume_token(GE);
          break;
          }
        case EQUAL:{
          jj_consume_token(EQUAL);
          break;
          }
        case NE:{
          jj_consume_token(NE);
          break;
          }
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression02();
      }
    } finally {
      trace_return("Expression01");
    }
  }

  final public void Expression02() throws ParseException {
    trace_call("Expression02");
    try {
      Expression03();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case CONCAT:{
          ;
          break;
          }
        default:
          jj_la1[77] = jj_gen;
          break label_17;
        }
        jj_consume_token(CONCAT);
        Expression03();
      }
    } finally {
      trace_return("Expression02");
    }
  }

  final public void Expression03() throws ParseException {
    trace_call("Expression03");
    try {
      Expression04();
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:
        case MINUS:{
          ;
          break;
          }
        default:
          jj_la1[78] = jj_gen;
          break label_18;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:{
          jj_consume_token(PLUS);
          break;
          }
        case MINUS:{
          jj_consume_token(MINUS);
          break;
          }
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression04();
      }
    } finally {
      trace_return("Expression03");
    }
  }

  final public void Expression04() throws ParseException {
    trace_call("Expression04");
    try {
      Expression05();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case STAR:
        case SLASH:{
          ;
          break;
          }
        default:
          jj_la1[80] = jj_gen;
          break label_19;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case STAR:{
          jj_consume_token(STAR);
          break;
          }
        case SLASH:{
          jj_consume_token(SLASH);
          break;
          }
        default:
          jj_la1[81] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Expression05();
      }
    } finally {
      trace_return("Expression04");
    }
  }

  final public void Expression05() throws ParseException {
    trace_call("Expression05");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT_OP:
      case PLUS:
      case MINUS:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case PLUS:{
          jj_consume_token(PLUS);
          break;
          }
        case MINUS:{
          jj_consume_token(MINUS);
          break;
          }
        case NOT_OP:{
          jj_consume_token(NOT_OP);
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        ;
      }
      Expression06();
    } finally {
      trace_return("Expression05");
    }
  }

  final public void Expression06() throws ParseException {
    trace_call("Expression06");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER:
      case FLOAT:
      case EXP:{
        Atom();
        break;
        }
      case STRINGLIT:{
        jj_consume_token(STRINGLIT);
        break;
        }
      case LPAREN:{
        jj_consume_token(LPAREN);
        Expression();
        jj_consume_token(RPAREN);
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LPAREN:
        case LBRACKET:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case LPAREN:{
            Call();
            break;
            }
          case LBRACKET:{
            Variable();
            break;
            }
          default:
            jj_la1[84] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[85] = jj_gen;
          ;
        }
        break;
        }
      default:
        jj_la1[86] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Expression06");
    }
  }

  final public void Variable() throws ParseException {
    trace_call("Variable");
    try {
      jj_consume_token(LBRACKET);
      Expression();
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case SLICE:{
        Slice();
        break;
        }
      case RBRACKET:{
        Subscripting();
        break;
        }
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Variable");
    }
  }

  final public void Slice() throws ParseException {
    trace_call("Slice");
    try {
      jj_consume_token(SLICE);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LPAREN:
      case LBRACE:
      case NOT_OP:
      case PLUS:
      case MINUS:
      case IDENTIFIER:
      case INTEGER:
      case FLOAT:
      case EXP:
      case STRINGLIT:{
        Expression();
        break;
        }
      case END_SYMBOL:{
        jj_consume_token(END_SYMBOL);
        break;
        }
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(RBRACKET);
    } finally {
      trace_return("Slice");
    }
  }

  final public void Subscripting() throws ParseException {
    trace_call("Subscripting");
    try {
      jj_consume_token(RBRACKET);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LBRACKET:{
          ;
          break;
          }
        default:
          jj_la1[89] = jj_gen;
          break label_20;
        }
        Index();
      }
    } finally {
      trace_return("Subscripting");
    }
  }

  final public void Index() throws ParseException {
    trace_call("Index");
    try {
      jj_consume_token(LBRACKET);
      Expression();
      jj_consume_token(RBRACKET);
    } finally {
      trace_return("Index");
    }
  }

  final public void ParamList() throws ParseException {
    trace_call("ParamList");
    try {
      Parameter();
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case COMMA:{
          ;
          break;
          }
        default:
          jj_la1[90] = jj_gen;
          break label_21;
        }
        jj_consume_token(COMMA);
        Parameter();
      }
    } finally {
      trace_return("ParamList");
    }
  }

  final public void Parameter() throws ParseException {
    trace_call("Parameter");
    try {
      DataType();
      jj_consume_token(IDENTIFIER);
    } finally {
      trace_return("Parameter");
    }
  }

/*****************************************
              DATA TYPE
*****************************************/
  final public 
void ScopeModifier() throws ParseException {
    trace_call("ScopeModifier");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case GLOBAL:{
        jj_consume_token(GLOBAL);
        break;
        }
      case PUBLIC:{
        jj_consume_token(PUBLIC);
        break;
        }
      case EXPORT:{
        jj_consume_token(EXPORT);
        break;
        }
      case OVERRIDE:{
        jj_consume_token(OVERRIDE);
        break;
        }
      default:
        jj_la1[91] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("ScopeModifier");
    }
  }

  final public void DataType() throws ParseException {
    trace_call("DataType");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ATOM:{
        jj_consume_token(ATOM);
        break;
        }
      case INT:{
        jj_consume_token(INT);
        break;
        }
      case SEQUENCE:{
        jj_consume_token(SEQUENCE);
        break;
        }
      case OBJECT:{
        jj_consume_token(OBJECT);
        break;
        }
      case IDENTIFIER:{
        jj_consume_token(IDENTIFIER);
        break;
        }
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("DataType");
    }
  }

  final public void Real() throws ParseException {
    trace_call("Real");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case FLOAT:{
        jj_consume_token(FLOAT);
        break;
        }
      case EXP:{
        jj_consume_token(EXP);
        break;
        }
      default:
        jj_la1[93] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Real");
    }
  }

  final public void Atom() throws ParseException {
    trace_call("Atom");
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case INTEGER:{
        jj_consume_token(INTEGER);
        break;
        }
      case FLOAT:
      case EXP:{
        Real();
        break;
        }
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      trace_return("Atom");
    }
  }

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_28()
 {
    if (!jj_rescan) trace_call("Call(LOOKING AHEAD...)");
    if (jj_scan_token(LPAREN)) { if (!jj_rescan) trace_return("Call(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Call(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_81()
 {
    if (!jj_rescan) trace_call("Ident(LOOKING AHEAD...)");
    if (jj_scan_token(IDENTIFIER)) { if (!jj_rescan) trace_return("Ident(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Ident(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_22()
 {
    if (!jj_rescan) trace_call("stmblk(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_26()) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) { if (!jj_rescan) trace_return("stmblk(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("stmblk(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_26()
 {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_64()
 {
    if (!jj_rescan) trace_call("TypeDeclare(LOOKING AHEAD...)");
    if (jj_scan_token(TYPE)) { if (!jj_rescan) trace_return("TypeDeclare(LOOKAHEAD FAILED)"); return true; }
    if (jj_scan_token(IDENTIFIER)) { if (!jj_rescan) trace_return("TypeDeclare(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("TypeDeclare(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_33()
 {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3R_75()
 {
    if (!jj_rescan) trace_call("IdentList(LOOKING AHEAD...)");
    if (jj_3R_81()) { if (!jj_rescan) trace_return("IdentList(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IdentList(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_52()
 {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_63()
 {
    if (!jj_rescan) trace_call("VarDeclare(LOOKING AHEAD...)");
    if (jj_3R_74()) { if (!jj_rescan) trace_return("VarDeclare(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_75()) { if (!jj_rescan) trace_return("VarDeclare(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("VarDeclare(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_47()
 {
    if (!jj_rescan) trace_call("Return(LOOKING AHEAD...)");
    if (jj_scan_token(RETURN)) { if (!jj_rescan) trace_return("Return(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_61()) { if (!jj_rescan) trace_return("Return(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Return(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_42()
 {
    if (!jj_rescan) trace_call("AssignmentWihOp(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(81)) {
    jj_scanpos = xsp;
    if (jj_scan_token(80)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) { if (!jj_rescan) trace_return("AssignmentWihOp(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("AssignmentWihOp(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_27()
 {
    if (!jj_rescan) trace_call("Assignment(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) { if (!jj_rescan) trace_return("Assignment(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Assignment(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_32()
 {
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_51()
 {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_41()
 {
    if (!jj_rescan) trace_call("AssignmentMulti(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) jj_scanpos = xsp;
    if (jj_scan_token(EQUAL)) { if (!jj_rescan) trace_return("AssignmentMulti(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("AssignmentMulti(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_43()
 {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_35()
 {
    if (!jj_rescan) trace_call("Atom(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_3R_43()) { if (!jj_rescan) trace_return("Atom(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Atom(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_78()
 {
    if (!jj_rescan) trace_call("SwitchTest(LOOKING AHEAD...)");
    if (jj_scan_token(SWITCH)) { if (!jj_rescan) trace_return("SwitchTest(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_61()) { if (!jj_rescan) trace_return("SwitchTest(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SwitchTest(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_53()
 {
    if (!jj_rescan) trace_call("Real(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(102)) {
    jj_scanpos = xsp;
    if (jj_scan_token(103)) { if (!jj_rescan) trace_return("Real(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Real(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_91()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_74()
 {
    if (!jj_rescan) trace_call("DataType(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) { if (!jj_rescan) trace_return("DataType(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("DataType(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_70()
 {
    if (!jj_rescan) trace_call("SwitchStatement(LOOKING AHEAD...)");
    if (jj_3R_78()) { if (!jj_rescan) trace_return("SwitchStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("SwitchStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_62()
 {
    if (!jj_rescan) trace_call("ScopeModifier(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) { if (!jj_rescan) trace_return("ScopeModifier(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("ScopeModifier(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_79()
 {
    if (!jj_rescan) trace_call("IfDefTest(LOOKING AHEAD...)");
    if (jj_scan_token(IFDEF)) { if (!jj_rescan) trace_return("IfDefTest(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(77)) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) { if (!jj_rescan) trace_return("IfDefTest(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IfDefTest(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_71()
 {
    if (!jj_rescan) trace_call("IfDefStatement(LOOKING AHEAD...)");
    if (jj_3R_79()) { if (!jj_rescan) trace_return("IfDefStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IfDefStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_60()
 {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_90()
 {
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }

  private boolean jj_3R_77()
 {
    if (!jj_rescan) trace_call("IfTest(LOOKING AHEAD...)");
    if (jj_scan_token(IF)) { if (!jj_rescan) trace_return("IfTest(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_61()) { if (!jj_rescan) trace_return("IfTest(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IfTest(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_65()
 {
    if (!jj_rescan) trace_call("Variable(LOOKING AHEAD...)");
    if (jj_scan_token(LBRACKET)) { if (!jj_rescan) trace_return("Variable(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Variable(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_57()
 {
    if (jj_scan_token(GOTO)) return true;
    if (jj_scan_token(LABELSTMT)) return true;
    return false;
  }

  private boolean jj_3R_59()
 {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_69()
 {
    if (!jj_rescan) trace_call("IfStatement(LOOKING AHEAD...)");
    if (jj_3R_77()) { if (!jj_rescan) trace_return("IfStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("IfStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_89()
 {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_88()
 {
    if (!jj_rescan) trace_call("Expression06(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) { if (!jj_rescan) trace_return("Expression06(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("Expression06(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_87()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(78)) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_86()
 {
    if (!jj_rescan) trace_call("Expression05(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) jj_scanpos = xsp;
    if (jj_3R_88()) { if (!jj_rescan) trace_return("Expression05(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression05(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_46()
 {
    if (!jj_rescan) trace_call("Branch(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) { if (!jj_rescan) trace_return("Branch(LOOKAHEAD FAILED)"); return true; }
    }
    }
    { if (!jj_rescan) trace_return("Branch(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_56()
 {
    if (jj_3R_68()) return true;
    return false;
  }

  private boolean jj_3R_58()
 {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3R_85()
 {
    if (!jj_rescan) trace_call("Expression04(LOOKING AHEAD...)");
    if (jj_3R_86()) { if (!jj_rescan) trace_return("Expression04(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression04(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_68()
 {
    if (!jj_rescan) trace_call("LoopStatement(LOOKING AHEAD...)");
    if (jj_scan_token(LOOP)) { if (!jj_rescan) trace_return("LoopStatement(LOOKAHEAD FAILED)"); return true; }
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(118)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(119)) jj_scanpos = xsp;
    if (jj_scan_token(DO)) { if (!jj_rescan) trace_return("LoopStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("LoopStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_24()
 {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_84()
 {
    if (!jj_rescan) trace_call("Expression03(LOOKING AHEAD...)");
    if (jj_3R_85()) { if (!jj_rescan) trace_return("Expression03(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression03(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_67()
 {
    if (!jj_rescan) trace_call("WhileStatement(LOOKING AHEAD...)");
    if (jj_scan_token(WHILE)) { if (!jj_rescan) trace_return("WhileStatement(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_61()) { if (!jj_rescan) trace_return("WhileStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("WhileStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_76()
 {
    if (!jj_rescan) trace_call("ForIDX(LOOKING AHEAD...)");
    if (jj_scan_token(IDENTIFIER)) { if (!jj_rescan) trace_return("ForIDX(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ForIDX(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_50()
 {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_83()
 {
    if (!jj_rescan) trace_call("Expression02(LOOKING AHEAD...)");
    if (jj_3R_84()) { if (!jj_rescan) trace_return("Expression02(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression02(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_55()
 {
    if (jj_3R_67()) return true;
    return false;
  }

  private boolean jj_3R_73()
 {
    if (jj_3R_80()) return true;
    return false;
  }

  private boolean jj_3R_82()
 {
    if (!jj_rescan) trace_call("Expression01(LOOKING AHEAD...)");
    if (jj_3R_83()) { if (!jj_rescan) trace_return("Expression01(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression01(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_23()
 {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_66()
 {
    if (!jj_rescan) trace_call("ForStatement(LOOKING AHEAD...)");
    if (jj_scan_token(FOR)) { if (!jj_rescan) trace_return("ForStatement(LOOKAHEAD FAILED)"); return true; }
    if (jj_3R_76()) { if (!jj_rescan) trace_return("ForStatement(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("ForStatement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_30()
 {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_80()
 {
    if (!jj_rescan) trace_call("Expression00(LOOKING AHEAD...)");
    if (jj_3R_82()) { if (!jj_rescan) trace_return("Expression00(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Expression00(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_49()
 {
    if (jj_3R_63()) return true;
    return false;
  }

  private boolean jj_3R_61()
 {
    if (!jj_rescan) trace_call("Expression(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) { if (!jj_rescan) trace_return("Expression(LOOKAHEAD FAILED)"); return true; }
    }
    { if (!jj_rescan) trace_return("Expression(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_72()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_45()
 {
    if (!jj_rescan) trace_call("Loop(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) { if (!jj_rescan) trace_return("Loop(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    { if (!jj_rescan) trace_return("Loop(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_54()
 {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3R_25()
 {
    if (!jj_rescan) trace_call("Object(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_29()) {
    jj_scanpos = xsp;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) {
    jj_scanpos = xsp;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) { if (!jj_rescan) trace_return("Object(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("Object(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_29()
 {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_scan_token(END_SYMBOL)) return true;
    return false;
  }

  private boolean jj_3R_44()
 {
    if (!jj_rescan) trace_call("Flow(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) { if (!jj_rescan) trace_return("Flow(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("Flow(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_48()
 {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_40()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    }
    return false;
  }

  private boolean jj_3R_34()
 {
    if (!jj_rescan) trace_call("Sequence(LOOKING AHEAD...)");
    if (jj_scan_token(LBRACE)) { if (!jj_rescan) trace_return("Sequence(LOOKAHEAD FAILED)"); return true; }
    { if (!jj_rescan) trace_return("Sequence(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  private boolean jj_3R_39()
 {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_38()
 {
    if (jj_3R_46()) return true;
    return false;
  }

  private boolean jj_3R_37()
 {
    if (jj_3R_45()) return true;
    return false;
  }

  private boolean jj_3R_36()
 {
    if (jj_3R_44()) return true;
    return false;
  }

  private boolean jj_3R_31()
 {
    if (!jj_rescan) trace_call("statement(LOOKING AHEAD...)");
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) { if (!jj_rescan) trace_return("statement(LOOKAHEAD FAILED)"); return true; }
    }
    }
    }
    }
    }
    { if (!jj_rescan) trace_return("statement(LOOKAHEAD SUCCEEDED)"); return false; }
  }

  /** Generated Token Manager. */
  public MeuphoriaTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[95];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x11136200,0x16000,0x100000,0x116000,0x0,0x0,0x11036200,0x0,0x11036200,0x11036200,0x0,0x16000,0x0,0x11020000,0x16000,0x0,0x11000000,0x0,0x11036200,0x0,0x0,0x0,0x400000,0x0,0x0,0x400000,0x11036200,0x20000,0x0,0x200000,0x0,0x11036200,0x11036200,0x11036200,0x0,0x80000000,0x0,0x0,0x0,0x0,0x11036200,0x0,0x0,0x0,0x0,0x11036200,0x11036200,0x400,0x11036200,0x200000,0x0,0x0,0x0,0x11036200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11036200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x16000,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x4001581f,0x8,0x4801,0x4809,0x10000,0x0,0x4001101e,0x0,0x4001101e,0x4001101e,0x80000000,0x8,0x10000,0x40001016,0x10008,0x0,0x40000004,0x0,0x4001101e,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x4001101e,0x1002,0x200,0x0,0x0,0x4001101e,0x4001101e,0x4001101e,0x20000000,0x0,0x0,0x0,0x0,0x0,0x4001101e,0x0,0x0,0x0,0x0,0x4001101e,0x4001101e,0x0,0x4001101e,0x0,0x20040,0x20040,0x0,0x4001101e,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4001101e,0x80000000,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x0,0x80000000,0x0,0x0,0x8,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x80000000,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x10bc048,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x0,0x0,0x2000,0xc000000,0x2000,0xc000000,0x80000000,0x2000,0xc000000,0x2000,0xc000000,0x80000000,0x80000000,0x0,0x80000000,0x0,0x0,0x0,0x0,0x80000000,0x40,0x10bc048,0x8,0x8,0x40,0x40,0xbc000,0x40,0x40,0x1000000,0x80000000,0x80000000,0xe002,0x40,0x40,0x2,0x40000002,0x2,0xe002,0x1c000000,0x1c000000,0x3f00000,0x3f00000,0x80000,0xc000,0xc000,0x30000,0x30000,0xe000,0xe000,0x8,0x8,0x0,0x210,0x4000e002,0x8,0x40,0x0,0x80000000,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x1f00000f,0x0,0x0,0x0,0x8,0xf,0x1f00000f,0xf,0x1f00000f,0x1f00000f,0x0,0x0,0xf,0x1f000000,0xf,0x1f000000,0x0,0x800000,0x1f00000f,0x0,0x400000,0x800000,0x0,0x400000,0x800000,0x0,0x1f00000f,0x0,0x0,0x0,0x800000,0x1f00000f,0x1f00000f,0x1f00000f,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00000f,0x0,0x0,0x0,0x0,0x1f00000f,0x1f00000f,0x0,0x1f00000f,0x0,0x0,0x0,0x800000,0x1f00000f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0x1f00000f,0x10e8,0x0,0x0,0x1fe8,0x1fe8,0x1fe8,0x10e8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10e8,0x0,0x10e8,0x0,0x0,0x0,0xf,0xc0,0xe0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Meuphoria(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Meuphoria(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Meuphoria(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Meuphoria(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    } else {
      trace_scan(jj_scanpos, kind);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[127];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 95; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 127; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
