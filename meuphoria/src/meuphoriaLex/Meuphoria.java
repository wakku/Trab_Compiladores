/* Meuphoria.java */
/* Generated By:JavaCC: Do not edit this line. Meuphoria.java */
/* MeuPhoria Parser */
class Meuphoria implements MeuphoriaConstants {

  /** Main entry point. */
  public static void main(String args[]) throws ParseException, TokenMgrError {
    try
    {
      Meuphoria analisadorlexico = new Meuphoria(System.in);
      analisadorlexico.Main();
      System.out.println("Analisado com sucesso!");
    }
    catch(ParseException e)
    {
        System.out.println(e.getMessage());
        System.out.println("Ocorreu uma excecao!");
    }
    catch(TokenMgrError e)
    {
        System.out.println(e.getMessage());
        System.out.println("Existem erros no codigo! Por favor, verifica-los.");
    }
  }

// 7 - IDENTIFIER

/*

TOKEN : { <ATOM : <ATOM_INTEGER_LIT>|<ATOM_REAL_LIT> > }       // 8 - ATOM

// GAMBI:
TOKEN : { <ATOM_INTEGER_LIT : "something"> }
TOKEN : { <ATOM_REAL_LIT : "something_else"> }
TOKEN : { <INTEGER : "something_other_thing"> }
TOKEN : { <INTEGER_LIT : "another_thing"> }
// END GAMBI

// // IDK HOW TO DO THIS
// TOKEN : { <ATOM_INTEGER_LIT : ["-253"-"+253"] | ["-9.007e15"-"+9.007e15"] > }                    // 9 - ATOM_INTEGER_INT - acho que está certo
// TOKEN : { <ATOM_REAL_LIT : ["-21024+1"-"+21024-1"] | ["-1.798e308+1"-"+1.798e308-1"]> }         // 10 - ATOM_REAL_LIT - acho que está certo
// TOKEN : { <INTEGER : <INTEGER_LIT> > }         // 11
// // IDK HOW TO DO THIS
// TOKEN : { <INTEGER_LIT : ["-230"-"+230-1"] | ["-1_073_741_824"-"+1_073_741_823"]> }         // 12

TOKEN : { <SEQUENCE : "{"<HEADITEM>(<ITEM>)+<LASTITEM> "}"> }      // 13
TOKEN : { <OBJECT : <ATOM>|<INTEGER>|<SEQUENCE> > }        // 14
TOKEN : { <EXPRESSION : <ATOMEXPR> | <INTEXPR> | <STREXPR> | <SEQEXPR> | <BOOLEXPR> > }        // 15
TOKEN : { <ATOMEXPR : <ATOM> > }       // 16
TOKEN : { <INTEXPR : <INTEGER> > }         // 17
TOKEN : { <STREXPR : "an_expression_that_evaluates_to_a_string"> }      // 18 - nÃO SEI SE ESTÁ CERTOOO
TOKEN : { <SEQEXPR : <SEQUENCE> > }        // 19

TOKEN : { <BOOL_LIT : "0" | "1" | "0" | "!0"> }         // 20

TOKEN : { <BOOLEXPR : "atom_zero_represents_falsehood_and_non-zero_represents_truth"> }     // 21 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <RELATIONOP : "<" | ">" | "<=" | ">=" | "=" | "!="> }     // 22 - 
TOKEN : { <BINARYEXPR : (<EXPRESSION> <BINOP> <EXPRESSION>)+ > }  // 23 - 
TOKEN : { <BINOP : "and" | "or" | "xor" | "+" | "-" | "*" | "/" | "&"> }    // 24 - 
TOKEN : { <UNARYEXPR : ( <UNARYOP> <EXPRESSION> )+ > }    // 25 - 
TOKEN : { <UNARYOP : "not" | "-" | "+"> }   // 26 - 
// 27 - RETIRADO DA GRAMATICA
TOKEN : { <HEADITEM : <ATOM>|<INTEGER> > }    // 28 - 
TOKEN : { <ITEM : "," <ATOM>|<INTEGER> > }     // 29 - 
TOKEN : { <LASTITEM : "$"> }    // 30 - 
TOKEN : { <STATEMENT : "complete_unit_of_code_executed_by_the_interpreter"> }   // 31 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <STMBLK : (<STATEMENT>)+ > }  // 32 - 

TOKEN : { <LABEL_EXP : "label"<STRINGLIT>> }     // 33 - 
//TOKEN : { <LISTDELIM : ","> }   // 34 - 
TOKEN : { <STRINGLIT : <SIMPLESTRINGLIT> | <RAWSTRINGLIT>> }    // 35 - 
TOKEN : { <SIMPLESTRINGLIT : <SSLITSTART> ( <CHAR> )+ <SSLITEND>> }  // 36 - 
TOKEN : { <SSLITSTART : "\""> }     // 37 - 
TOKEN : { <SSLITEND : <SSLITSTART>> }   // 38 - 
TOKEN : { <CHAR : "any_byte_value"> }   // 39 - 
TOKEN : { <EESCHAR : <ESCLEAD> ( "t" | "n" | "r" | " " )> }     // 40 - 
TOKEN : { <ESCLEAD : ""> }  // 41 - 

TOKEN : { <RAWSTRINGLIT : <DQRAWSTRING> | <BQRAWSTRING>> }  // 42 - 
TOKEN : { <DQRAWSTRING : "\"\"\"" <MARGINSTR> ( <CHAR> )+ "\"\"\""> }    // 43 - 
TOKEN : { <BQRAWSTRING : "`"  <MARGINSTR> ( <CHAR> )+ "`"> }  // 44 -
TOKEN : { <MARGINSTR : <USCORE>> }   // 45 -  
TOKEN : { <SCOPEMODIFIER : "global" | "public" | "export" | "override"> }   // 46 - 
//TOKEN : { <DATATYPE : "atom" | "integer" | "sequence" | "object" | <IDENTIFIER>> }    // 47 - 
TOKEN : { <INCLUDESTMT : "include" <FILEREF> ( "as" <NAMESPACEID> ) <EOL>> }  // 48 - 
TOKEN : { <FILEREF : "file_path_that_may_be_enclosed_in_double-quotes"> }   // 49 -
TOKEN : { <NAMESPACEID : <IDENTIFIER>> }  // 50 -
TOKEN : { <SLICE : <LBRACKET> <INTEXPR> <SLICEDELIM> ( <INTEXPR> | "$" ) <RBRACKET>> }  // 51 -  
//TOKEN : { <SLICESTART : "["> }  // 52 -  
TOKEN : { <SLICEDELIM : ".."> }     // 53 -  
//TOKEN : { <SLICEEND : "]"> }    // 54 -  
TOKEN : { <IFSTMT : <IF_TEST> ( <ELSIF_TEST> )* ( <ELSE_TEST> )? <ENDIF>> }  // 55 -  
TOKEN : { <IF_TEST : "if" <ATOMEXPR>  (<LABEL_EXP>)? "then" (<STMBLK>)?> }    // 56 -    
TOKEN : { <ELSIF_TEST : "elsif" <ATOMEXPR> "then" (<STMBLK>)?> }    // 57 -  
TOKEN : { <ELSE_TEST : "else" (<STMBLK>)?> }  // 58 -  
TOKEN : { <ENDIF : "end" "if"> }    // 59 -  
TOKEN : { <IFDEFSTMT : <IFDEFTEST> (<ELSDEFIF> (<CHAR>)+)? (<ELSEDEF_TEST>)? <ENDDEFIF>> }  // 60 -  
TOKEN : { <IFDEFTEST : "ifdef" <DEFEXPR> "then" (<STMBLK>)? > }     // 61 -  
TOKEN : { <ELSDEFIF : "elsifedf" <DEFEXPR> "then" (<STMBLK>)? > }   // 62 -    
TOKEN : { <ELSEDEF_TEST : "elsede" (<STMBLK>)? > }  // 63 -  
TOKEN : { <ENDDEFIF : "end" "ifdef"> }  // 64 -  
TOKEN : { <DEFEXPR : <DEFTERM> (<DEFOP> <DEFTERM>)? > }   // 65 -  
TOKEN : { <DEFTERM : ("not" <IDENTIFIER>)? > }    // 66 -  
TOKEN : { <DEFOP : "and" | "or"> }  // 67 -  
TOKEN : { <SWITCHSTMT : <SWITCHTEST> (<CASE_EXP>)+ (<CASEELSE>)? (<ENDSWITCH>)? > }  // 68 -    
TOKEN : { <SWITCHTEST : "switch" <EXPRESSION> (<WITHFALL>)? (<LABEL_EXP>)? "do"> }  // 69 -  
TOKEN : { <WITHFALL : ( "with" | "without" ) "fallthru"> }  // 70 -  
TOKEN : { <CASE_EXP : "case" <CASELIST> "then" (<STMBLK>)?> }  // 71 -  
TOKEN : { <CASELIST : <EXPRESSION> (<COMMA> <EXPRESSION>)+ > }    // 72 -  
TOKEN : { <CASEELSE : "case" "else"> }  // 73 -  
TOKEN : { <ENDSWITCH : "end" "switch"> }    // 74 -    
TOKEN : { <BREAKSTMT : "break" (<STRINGLIT>)?> }     // 75 -  
TOKEN : { <CONTINUESTMT : "continue" (<STRINGLIT>)? > }   // 76 -  
TOKEN : { <RETRYSTMT : "retry" (<STRINGLIT>)? > }     // 77 -  
TOKEN : { <EXITSTMT : "exit" (<STRINGLIT>)? > }   // 78 -  

//TOKEN : { <FALLTHRUSTMT : "fallthru"> }     // 79 -  
TOKEN : { <FORSTMT : "for" <FORIDX> (<LABEL_EXP>)? "do" (<STMBLK>)? "end" "for"> }  // 80 -    
TOKEN : { <FORIDX : <IDENTIFIER> "=" <ATOMEXPR> "to" <ATOMEXPR> ("by"<ATOMEXPR>)? > }  // 81 -  
TOKEN : { <WHILESTMT : "while" <BOOLEXPR> (<WITHENTRY>)? (<LABEL_EXP>)? "do" <STMBLK> (<ENTRY_EXP>)? "end" "while"> }  // 82 -  
TOKEN : { <WITHENTRY : "with" "entry"> }    // 83 -  
TOKEN : { <ENTRY_EXP : "entry" (<STMBLK>)?> }    // 84 -  
TOKEN : { <LOOPSTMT : "loop" (<WITHENTRY>)? (<LABEL_EXP>)? "do" <STMBLK> (<ENTRY_EXP>)? "until" <BOOLEXPR> "end" "loop"> }   // 85 -  
TOKEN : { <GOTOSTMT : "goto" <LABEL_EXP>> }   // 86 -
TOKEN : { <VARDECLARE : (<SCOPEMODIFIER>)? <DATATYPE> <IDENTLIST>> }     // 87 -        
TOKEN : { <IDENTLIST : <IDENT> ("," <IDENT>)+> }   // 88 -        
TOKEN : { <IDENT : <IDENTIFIER> ("=" <EXPRESSION>)?> }     // 89 -
TOKEN : { <CONSTDECLARE : (<SCOPEMODIFIER>)? "constant" <IDENTLIST>> }     // 90 -                
TOKEN : { <ENUMDECLARE : (<SCOPEMODIFIER>)? (<ENUMVAL> | <ENUMTYPE>)?> }    // 91 -                
TOKEN : { <ENUMVAL : "enum" ("by" <ENUMDELTA>)? <IDENTLIST>> }     // 92 -                
TOKEN : { <ENUMDELTA : ("+" | "-" | "*" | "/")? <ATOMEXPR>> }    // 93 -                
TOKEN : { <ENUMTYPE : "enum" "type" ("by" <ENUMDELTA>)? <IDENTLIST> "end" "type"> }    // 94 -                
TOKEN : { <CALL : <IDENTIFIER> "(" (<ARGLIST>)? ")"> }     // 95 -                
TOKEN : { <ARGLIST : <ARGUMENT> ("," <ARGUMENT>)+> }    // 96 -                
TOKEN : { <ARGUMENT : <EXPRESSION>> }     // 97 -                
TOKEN : { <PROCDECLARE : (<SCOPEMODIFIER>)? "procedure" <IDENTIFIER> "(" (<PARAMLIST>)? ")" (<STMBLK>)? "end" "procedure"> }     // 98 -                
TOKEN : { <PARAMLIST : <PARAMETER> ("," <PARAMETER>)+> }   // 99 -
TOKEN : { <PARAMETER : <DATATYPE> <IDENTIFIER>> }   // 100 -
TOKEN : { <FUNCDECLARE : (<SCOPEMODIFIER>)? "function" <IDENTIFIER> "(" (<PARAMLIST>)? ")" (<STMBLK>)? "end" "function"> }   // 101 -
TOKEN : { <TYPEDECLAR : (<SCOPEMODIFIER>)? "type" <IDENTIFIER> "(" <PARAMETER> ")" (<STMBLK>)? "end" "type"> }    // 102 -
TOKEN : { <RETURN_EXP : "return" <EXPRESSION>> }  // 103 -
TOKEN : { <NAMESPACE_EXP : "namespace" <IDENTIFIER> <EOL>> }    // 104 -
TOKEN : { <WITHSTMT : ("with" | "without")? <WITHOPTION>> }  // 105 -
TOKEN : { <WITHOPTION : ("profile" | "profile_time" | "trace" | "batch" | "type_check" | "indirect_includes" | "inline" | <WITHWARNING>)? > }     // 106 -
TOKEN : { <WITHWARNING : "warning" (<WARNOPT>)?> }   // 107 -
TOKEN : { <WARNOPT : <SETWARN> | (<ADDWARN>)? | <SAVEWARN> | <RESTOREWARN> | <STRICTWARN>> }    // 108 - addwarn não foi criado?
TOKEN : { <SETWARN : ("+=" | "&=")? "{" (<WARNLIST>)? "}"> }   // 109 - warnlist não foi criado em nenhum lugar :/
TOKEN : { <WARNLIST : "warnlist"> }// Pensei em criar assim, pelo que entendi é a lista impressa dos erros, não acho que vamos fazer algo no lexico
TOKEN : { <ADDWARN : "add"> }// Pensei em criar assim
TOKEN : { <SAVEWARN : "save"> }     // 110 -
TOKEN : { <RESTOREWARN : "restore"> }   // 111 -
TOKEN : { <STRICTWARN : "strict"> }     // 112 -
TOKEN : { <SUBSCRIPTING : <IDENTIFIER> (<INDEX>)+ > }   // 113 -
TOKEN : { <INDEX : "[" <INTEXPR> "]"> }   // 114 -
TOKEN : { <ASSIGNMONO : <IDENTIFIER> "=" <EXPRESSION>> }    // 115 -
TOKEN : { <ASSIGNMULTI : "{" <IDENTIFIER> ( "," <IDENTIFIER>)* "}" "=" <EXPRESSION> | "{" <EXPRESSION> ( "," <EXPRESSION> )* "}"> }    // 116 -
TOKEN : { <ASSIGNWITHOP : <IDENTIFIER> ( "+" | "-" | "/" | "*" | "&" )? "=" <EXPRESSION>> }  // 117 -

*/


/* THE CODE HAS TO BE CHANGED FROM THIS POINT ON */


/************************
          MAIN
************************/
  final public void Main() throws ParseException {Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMENTARIO_INICIAL:
      case COMENTARIO_LINHA:
      case COMENTARIO_BLOCO:
      case CONSTANT:
      case ENUM:
      case RETURN:
      case LPAREN:
      case RPAREN:
      case COMMA:
      case ASSIGN:
      case ID:
      case INT:
      case FLOAT:
      case STRING:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:{
        /************ GERAIS ************/
            //t = <EOL>         { System.out.println("@ EOL:\t"+t.toString());}
        
            /************ VARIAVEIS ************/
        
              t = jj_consume_token(ID);
System.out.println("@("+t.beginLine+","+t.beginColumn+") ID:\u005ct"+t.toString());
        break;
        }
      case INT:{
        t = jj_consume_token(INT);
System.out.println("@("+t.beginLine+","+t.beginColumn+") INT:\u005ct"+t.toString());
        break;
        }
      case FLOAT:{
        t = jj_consume_token(FLOAT);
System.out.println("@("+t.beginLine+","+t.beginColumn+") FLOAT:\u005ct"+t.toString());
        break;
        }
      case STRING:{
        t = jj_consume_token(STRING);
System.out.println("@("+t.beginLine+","+t.beginColumn+") STRING:\u005ct"+t.toString());
        break;
        }
      case COMENTARIO_INICIAL:{
        t = jj_consume_token(COMENTARIO_INICIAL);
System.out.println("@("+t.beginLine+","+t.beginColumn+") COMENTARIO_INICIAL:\u005ct"+t.toString());
        break;
        }
      case COMENTARIO_LINHA:{
        t = jj_consume_token(COMENTARIO_LINHA);
System.out.println("@("+t.beginLine+","+t.beginColumn+") COMENTARIO_LINHA:\u005ct"+t.toString());
        break;
        }
      case COMENTARIO_BLOCO:{
        t = jj_consume_token(COMENTARIO_BLOCO);
System.out.println("@("+t.beginLine+","+t.beginColumn+") COMENTARIO_BLOCO:\u005ct"+t.toString());
        break;
        }
      case CONSTANT:{
        t = jj_consume_token(CONSTANT);
System.out.println("@("+t.beginLine+","+t.beginColumn+") CONSTANT:\u005ct"+t.toString());
        break;
        }
      case ENUM:{
        t = jj_consume_token(ENUM);
System.out.println("@("+t.beginLine+","+t.beginColumn+") ENUM:\u005ct"+t.toString());
        break;
        }
      case COMMA:{
        t = jj_consume_token(COMMA);
System.out.println("@("+t.beginLine+","+t.beginColumn+") COMMA:\u005ct"+t.toString());
        break;
        }
      case LPAREN:{
        t = jj_consume_token(LPAREN);
System.out.println("@("+t.beginLine+","+t.beginColumn+") LPAREN:\u005ct"+t.toString());
        break;
        }
      case RPAREN:{
        t = jj_consume_token(RPAREN);
System.out.println("@("+t.beginLine+","+t.beginColumn+") RPAREN:\u005ct"+t.toString());
        break;
        }
      case ASSIGN:{
        t = jj_consume_token(ASSIGN);
System.out.println("@("+t.beginLine+","+t.beginColumn+") ASSIGN:\u005ct"+t.toString());
        break;
        }
      case RETURN:{
        t = jj_consume_token(RETURN);
System.out.println("@("+t.beginLine+","+t.beginColumn+") RETURN:\u005ct"+t.toString());
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  /** Generated Token Manager. */
  public MeuphoriaTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2000e0,0x2000e0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x48300044,0x48300044,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x3c0,0x3c0,};
   }

  /** Constructor with InputStream. */
  public Meuphoria(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Meuphoria(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Meuphoria(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Meuphoria(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[110];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 110; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
