/* Meuphoria.java */
/* Generated By:JavaCC: Do not edit this line. Meuphoria.java */
/* MeuPhoria Parser */
class Meuphoria implements MeuphoriaConstants {

  /** Main entry point. */
  public static void main(String args[]) throws ParseException, TokenMgrError {
    try
    {
      Meuphoria analisadorlexico = new Meuphoria(System.in);
      analisadorlexico.Main();
      System.out.println("Analisado com sucesso!");
  }
  catch(ParseException e)
  {
      System.out.println(e.getMessage());
      System.out.println("Ocorreu uma excecao!");
  }
  catch(TokenMgrError e)
  {
      System.out.println(e.getMessage());
      System.out.println("Existem erros no codigo! Por favor, verifica-los.");
  }
}

// 7 - IDENTIFIER

/*

TOKEN : { <ATOM : <ATOM_INTEGER_LIT>|<ATOM_REAL_LIT> > }       // 8 - ATOM

// IDK HOW TO DO THIS
TOKEN : { <ATOM_INTEGER_LIT : ["-253"-"+253"] | ["-9.007e15"-"+9.007e15"] > }                    // 9 - ATOM_INTEGER_INT - acho que está certo
TOKEN : { <ATOM_REAL_LIT : ["-21024+1"-"+21024-1"] | ["-1.798e308+1"-"+1.798e308-1"]> }         // 10 - ATOM_REAL_LIT - acho que está certo

TOKEN : { <INTEGER : <INTEGER_LIT> > }         // 11

// IDK HOW TO DO THIS
TOKEN : { <INTEGER_LIT : ["-230"-"+230-1"] | ["-1_073_741_824"-"+1_073_741_823"]> }         // 12

TOKEN : { <SEQUENCE : "{"(<HEADITEM>)+(<ITEM>|<LASTITEM>) "}"> }      // 13
TOKEN : { <OBJECT : <ATOM>|<INTEGER>|<SEQUENCE> > }        // 14
TOKEN : { <EXPRESSION : <ATOMEXPR> | <INTEXPR> | <STREXPR> | <SEQEXPR> | <BOOLEXPR> > }        // 15
TOKEN : { <ATOMEXPR : <ATOM> > }       // 16
TOKEN : { <INTEXPR : <INTEGER> > }         // 17
TOKEN : { <STREXPR : "an_expression_that_evaluates_to_a_string"> }      // 18 - nÃO SEI SE ESTÁ CERTOOO
TOKEN : { <SEQEXPR : <SEQUENCE> > }        // 19

TOKEN : { <BOOL_LIT : "0" | "1" | "0" | "!0"> }         // 20

TOKEN : { <BOOLEXPR : "atom_zero_represents_falsehood_and_non-zero_represents_truth"> }     // 21 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <RELATIONOP : "<" | ">" | "<=" | ">=" | "=" | "!="> }     // 22 - 
TOKEN : { <BINARYEXPR : (<EXPRESSION> <BINOP> <EXPRESSION>)+ > }  // 23 - 
TOKEN : { <BINOP : "and" | "or" | "xor" | "+" | "-" | "*" | "/" | "&"> }    // 24 - 
TOKEN : { <UNARYEXPR : { <UNARYOP> <EXPRESSION> }> }    // 25 - 
TOKEN : { <UNARYOP : "not" | "-" | "+"> }   // 26 - 
// 27 - RETIRADO DA GRAMATICA
TOKEN : { <HEADITEM : <OBJECT> "," > }    // 28 - 
TOKEN : { <ITEM : <OBJECT> > }     // 29 - 
TOKEN : { <LASTITEM : "$"> }    // 30 - 
TOKEN : { <STATEMENT : "complete_unit_of_code_executed_by_the_interpreter"> }   // 31 - NÃO SEI SE ESTÁ CERTO
TOKEN : { <STMBLK : (<STATEMENT>)+ > }  // 32 - 

TOKEN : { <LABEL : "label" STRINGLIT> }     // 33 - 
TOKEN : { <LISTDELIM : ","> }   // 34 - 
TOKEN : { <STRINGLIT : SIMPLESTRINGLIT | RAWSTRINGLIT> }    // 35 - 
TOKEN : { <SIMPLESTRINGLIT : SSLITSTART { CHAR | ESCCHAR } SSLITEND> }  // 36 - 
TOKEN : { <SSLITSTART : "\""> }     // 37 - 
TOKEN : { <SSLITEND : "\""> }   // 38 - 
TOKEN : { <CHAR : "any_byte_value"> }   // 39 - 
TOKEN : { <EESCHAR : ESCLEAD41 ( "t" | "n" | "r" | " " )> }     // 40 - 
TOKEN : { <ESCLEAD : ""> }  // 41 - 
TOKEN : { <RAWSTRINGLIT : DQRAWSTRING | BQRAWSTRING> }  // 42 - 
TOKEN : { <DQRAWSTRING : "\"\"\"" [ MARGINSTR ] { CHAR } "\"\"\""> }    // 43 - 
TOKEN : { <BQRAWSTRING : "`" [ MARGINSTR ] { CHAR } "`"> }  // 44 -
TOKEN : { <MARGINSTR : "_"> }   // 45 -  

// tirei 2 linhas e coloquei para cima

TOKEN : { <INCLUDESTMT : "include" FILEREF [ "as" NAMESPACEID ] EOL> }  // 48 - 
TOKEN : { <FILEREF : "file_path_that_may_be_enclosed_in_double-quotes"> }   // 49 -
TOKEN : { <NAMESPACEID : IDENTIFIER> }  // 50 -
TOKEN : { <SLICE : SLICESTART INTEXPR SLICEDELIM ( INTEXPR | "$" ) SLICEEND> }  // 51 -  
TOKEN : { <SLICESTART : "["> }  // 52 -  
TOKEN : { <SLICEDELIM : ".."> }     // 53 -  
TOKEN : { <SLICEEND : "]"> }    // 54 -  
TOKEN : { <IFSTMT : IFTEST { ELSIF } [ ELSE ] ENDIF> }  // 55 -  
TOKEN : { <IFTEST : "if" ATOMEXPR [ LABEL ] "then" [ STMBLK ]> }    // 56 -    
TOKEN : { <ELSIF : "elsif" ATOMEXPR "then" [ STMBLK ]> }    // 57 -  
TOKEN : { <ELSE : "else" [ STMBLK ]> }  // 58 -  
TOKEN : { <ENDIF : "end" "if"> }    // 59 -  
TOKEN : { <IFDEFSTMT : IFDEFTEST [ ELSDEFIT { CHAR } ] [ ELSEDEF ] ENDDEFIF> }  // 60 -  
TOKEN : { <IFDEFTEST : "ifdef" DEFEXPR "then" [ STMBLK ]> }     // 61 -  
TOKEN : { <ELSDEFIF : "elsifedf" DEFEXPR "then" [ STMBLK ]> }   // 62 -    
TOKEN : { <ELSEDEF : "elsede" [STMBLK]> }  // 63 -  
TOKEN : { <ENDDEFIF : "end" "ifdef"> }  // 64 -  
TOKEN : { <DEFEXPR : DEFTERM [ DEFOP DEFTERM ]> }   // 65 -  
TOKEN : { <DEFTERM : [ "not" IDENTIFIER ]> }    // 66 -  
TOKEN : { <DEFOP : "and" | "or"> }  // 67 -  
TOKEN : { <SWITCHSTMT : SWITCHTEST CASE { CASE } [ CASEELSE ] [ ENDSWITCH ]> }  // 68 -    
TOKEN : { <SWITCHTEST : "switch" EXPRESSION [ WITHFALL ] [ LABEL ] "do"> }  // 69 -  
TOKEN : { <WITHFALL : ( "with" | "without" ) "fallthru"> }  // 70 -  
TOKEN : { <CASE : "case" CASELIST "then" [ STMBLK ]> }  // 71 -  
TOKEN : { <CASELIST : EXPRESSION { LISTDELIM EXPRESSION }> }    // 72 -  
TOKEN : { <CASEELSE : "case" "else"> }  // 73 -  
TOKEN : { <ENDSWITCH : "end" "switch"> }    // 74 -    
TOKEN : { <BREAKSTMT : "break" [ STRINGLIT ]> }     // 75 -  
TOKEN : { <CONTINUESTMT : "continue" [ STRINGLIT ]> }   // 76 -  
TOKEN : { <RETRYSTMT : "retry" [ STRINGLIT ]> }     // 77 -  
TOKEN : { <EXITSTMT : "exit" [ STRINGLIT ]> }   // 78 -  
TOKEN : { <FALLTHRUSTMT : "fallthru"> }     // 79 -  
TOKEN : { <FORSTMT : "for" FORIDX [ LABEL ] "do" [ STMBLK ] "end" "for"> }  // 80 -    
TOKEN : { <FORIDX : IDENTIFIER "=" ATOMEXPR "to" ATOMEXPR [ "by" ATOMEXPR ]> }  // 81 -  
TOKEN : { <WHILESTMT : "while" BOOLEXPR [ WITHENTRY ] [ LABEL ] "do" STMBLK [ ENTRY ] "end" "while"> }  // 82 -  
TOKEN : { <WITHENTRY : "with" "entry"> }    // 83 -  
TOKEN : { <ENTRY : "entry" [ STMBLK ]> }    // 84 -  
TOKEN : { <LOOPSTMT : "loop" [ withentry83 ] [ label33 ] "do" stmblk32 [ entry84 ] "until" boolexpr21 "end" "loop"> }   // 85 -  
TOKEN : { <GOTOSTMT : "goto" LABEL> }   // 86 -
TOKEN : { <VARDECLARE : [ SCOPEMODIFIER ] DATATYPE IDENTLIST> }     // 87 -        
TOKEN : { <IDENTLIST : IDENT [ "," IDENTLIST ]> }   // 88 -        
TOKEN : { <IDENT : IDENTIFIER [ "=" EXPRESSION ]> }     // 89 -
TOKEN : { <CONSTDECLARE : [ SCOPEMODIFIER ] "constant" IDENTLIST> }     // 90 -                
TOKEN : { <ENUMDECLARE : [ SCOPEMODIFIER ] [ ENUMVAL | ENUMTYPE ]> }    // 91 -                
TOKEN : { <ENUMVAL : "enum" [ "by" ENUMDELTA ] IDENTLIST> }     // 92 -                
TOKEN : { <ENUMDELTA : [ "+" | "-" | "*" | "/" ] ATOMEXPR> }    // 93 -                
TOKEN : { <ENUMTYPE : "enum" "type" [ "by" ENUMDELTA ] IDENTLIST "end" "type"> }    // 94 -                
TOKEN : { <CALL : IDENTIFIER "(" [ ARGLIST ] ")"> }     // 95 -                
TOKEN : { <ARGLIST : ARGUMENT [ "," ARGLIST ]> }    // 96 -                
TOKEN : { <ARGUMENT : EXPRESSION> }     // 97 -                
TOKEN : { <PROCDECLARE : [ SCOPEMODIFIER ] "procedure" IDENTIFIER "(" [ PARAMLIST ] ")" [ STMBLK ] "end" "procedure"> }     // 98 -                
TOKEN : { <PARAMLIST : PARAMETER [ "," PARAMLIST ]> }   // 99 -
TOKEN : { <PARAMETER : DATATYPE IDENTIFIER> }   // 100 -
TOKEN : { <FUNCDECLARE : [ SCOPEMODIFIER ] "function" IDENTIFIER "(" [ PARAMLIST ] ")" [ STMBLK ] "end" "function"> }   // 101 -
TOKEN : { <TYPEDECLAR : [ SCOPEMODIFIER ] "type" IDENTIFIER "(" PARAMETER ")" [ STMBLK ] "end" "type"> }    // 102 -
TOKEN : { <RETURN : "return" EXPRESSION> }  // 103 -
TOKEN : { <NAMESPACE : "namespace" IDENTIFIER EOL> }    // 104 -
TOKEN : { <WITHSTMT : [ "with" | "without" ] WITHOPTION> }  // 105 -
TOKEN : { <WITHOPTION : [ "profile" | "profile_time" | "trace" | "batch" | "type_check" | "indirect_includes" | "inline" | WITHWARNING ]> }     // 106 -
TOKEN : { <WITHWARNING : "warning" [ WARNOPT ]> }   // 107 -
TOKEN : { <WARNOPT : SETWARN | ADDWARN? | SAVEWARN | RESTOREWARN | STRICTWARN> }    // 108 - addwarn não foi criado?
TOKEN : { <SETWARN : [ "+=" | "&=" ] "{" WARNLIST? "}"> }   // 109 - warnlist não foi criado em nenhum lugar :/
// TOKEN : { <WARNLIST : "warnlist"> } Pensei em criar assim, pelo que entendi é a lista impressa dos erros, não acho que vamos fazer algo no lexico
// TOKEN : { <ADDWARN : "add"> } Pensei em criar assim
TOKEN : { <SAVEWARN : "save"> }     // 110 -
TOKEN : { <RESTOREWARN : "restore"> }   // 111 -
TOKEN : { <STRICTWARN : "strict"> }     // 112 -
TOKEN : { <SUBSCRIPTING : IDENTIFIER { INDEX }> }   // 113 -
TOKEN : { <INDEX : "[" INTEXPR "]"> }   // 114 -
TOKEN : { <ASSIGNMONO : IDENTIFIER "=" EXPRESSION> }    // 115 -
TOKEN : { <ASSIGNMULTI : "{" IDENTIFIER [ { "," IDENTIFIER } ] "}" "=" EXPRESSION | "{" EXPRESSION [ { "," EXPRESSION } ] "}"> }    // 116 -
TOKEN : { <ASSIGNWITHOP : IDENTIFIER ( "+" | "-" | "/" | "*" | "&" ) "=" EXPRESSION> }  // 117 -

*/

/* THE CODE HAS TO BE CHANGED FROM THIS POINT ON */

/************************

Não comecei esssa parte aindaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, é só para ter a ideia, é beeeem de boa, só crtl+c, ctrl+v no token, e mudar o sysout blz?




/************************
MAIN
************************/
  final public void Main() throws ParseException {Token t;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case COMENTARIO_INICIAL:
      case EOL:
      case IDENTIFIER:{
        ;
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case EOL:{
        /************ GERAIS ************/
            t = jj_consume_token(EOL);
System.out.println("@("+t.beginLine+","+t.beginColumn+") EOL:\u005ct"+t.toString());
        break;
        }
      case IDENTIFIER:{
        t = jj_consume_token(IDENTIFIER);
System.out.println("@("+t.beginLine+","+t.beginColumn+") IDENTIFIER:\u005ct"+t.toString());
        break;
        }
      case COMENTARIO_INICIAL:{
        t = jj_consume_token(COMENTARIO_INICIAL);
System.out.println("@("+t.beginLine+","+t.beginColumn+") COMENTARIO_INICIAL:\u005ct"+t.toString());
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  /** Generated Token Manager. */
  public MeuphoriaTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[2];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10,0x10,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x9,0x9,};
   }

  /** Constructor with InputStream. */
  public Meuphoria(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Meuphoria(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Meuphoria(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MeuphoriaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Meuphoria(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MeuphoriaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 2; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[68];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 2; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 68; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
